<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dart Übersicht</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      color-scheme: light dark;
      /* Dunkelgrünes Schema */
      --bg:#0f2a1f;
      --panel:#123527;
      --card:#15402f;
      --border:#1f5640;
      --text:#e9f5ee;
      --muted:#c3d9ce;
      --accent:#7df9c6;       /* frisches Türkisgrün als Akzent */
      --accent-strong:#4fd6a5;
      font-family:"Inter",system-ui,-apple-system,sans-serif;
    }
    body{
      margin:0;
      min-height:100vh;
      background:
        radial-gradient(circle at 20% 20%, rgba(125,249,198,0.10), transparent 35%),
        radial-gradient(circle at 80% 0%, rgba(79,214,165,0.10), transparent 40%),
        var(--bg);
      color:var(--text);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:32px;
    }
    .page{ width:min(1200px,100%); display:grid; gap:24px; }
    header{ display:flex; flex-direction:column; align-items:center; justify-content:center; gap:6px; text-align:center; }
    h1{ margin:0; font-size:clamp(26px,3vw,34px); letter-spacing:-0.02em; }
    .tagline{ color:var(--muted); margin:4px 0 0; font-size:15px; }

    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0));
      border:1px solid var(--border);
      border-radius:18px;
      padding:18px;
      box-shadow:0 24px 60px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
    }

    button{
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      color:#1b0c12;
      border:none;
      border-radius:12px;
      padding:10px 16px;
      font-weight:700;
      cursor:pointer;
      transition: transform .15s ease, filter .15s ease, box-shadow .15s ease;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }
    button:hover{ transform: translateY(-1px); filter: brightness(1.03); box-shadow:0 14px 34px rgba(0,0,0,0.35); }
    button[disabled]{ opacity:.45; cursor:not-allowed; transform:none; filter:none; }

    .ghost-btn{
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer;
      transition: all .15s ease;
    }
    .ghost-btn:hover{
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(255,209,102,0.14);
      transform: translateY(-1px);
    }
    .ghost-btn[disabled]{ opacity:.35; cursor:not-allowed; transform:none; }
    .ghost-compact{ padding:6px 10px; font-size:13px; }
    .danger{
      border-color:#ef4444;
      color:#ef4444;
    }
    .danger:hover{
      border-color:#ef4444;
      color:#ef4444;
      background: rgba(239,68,68,0.10);
    }

    .score-card{ display:grid; gap:14px; }
    .score-header{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .player-form{ display:flex; gap:8px; flex-wrap:wrap; }
    input, select{
      background: rgba(255,255,255,0.04);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
      color: var(--text);
      min-width: 150px;
    }
    select{ background: var(--card); }

    .table-wrap{ overflow-x:auto; }
    .table-wrap table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      min-width: 420px;
    }
    .table-wrap th, .table-wrap td{
      padding:10px 8px;
      text-align:left;
      border-bottom:1px solid rgba(255,255,255,0.08);
      font-size:14px;
    }
    .table-wrap thead{ color:var(--muted); font-weight:600; letter-spacing:.01em; }

    /* Player Cards */
    .player-grid{
      display:grid;
      gap:12px;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      margin-top:12px;
    }
    .player-card{
      background: var(--card);
      border:1px solid var(--border);
      border-radius:14px;
      padding:14px;
      box-shadow:0 16px 40px rgba(0,0,0,0.35);
      display:flex;
      flex-direction:column;
      gap:10px;
      transition: transform .18s ease, box-shadow .18s ease, border-color .18s ease, background .18s ease;
    }
    .player-card:hover{
      transform: translateY(-2px);
      box-shadow:0 20px 44px rgba(0,0,0,0.4);
    }
    .player-card.active-player{
      border-color: rgba(255,209,102,0.9);
      box-shadow:0 24px 50px rgba(255,209,102,0.18);
      background: linear-gradient(180deg, rgba(255,209,102,0.08), rgba(255,209,102,0.03));
    }
    .player-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }
    .crown{
      font-size:14px;
      line-height:1;
      opacity:0.8;
      min-width:16px;
      text-align:left;
    }
    .player-name{
      font-weight:700;
      font-size:16px;
      color:var(--text);
    }
    .player-meta{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
    }
    .big-score{
      font-size:clamp(26px, 5vw, 34px);
      font-weight:800;
      letter-spacing:-0.02em;
      color:var(--text);
      margin:0;
    }
    .meta-row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.1);
      color:var(--text);
      font-weight:600;
      font-size:12px;
    }
    .player-actions{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:auto;
    }

    .action-group{ display:flex; gap:6px; align-items:center; flex-wrap:wrap; }
    .action-group input{
      width: 92px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 10px;
      color: var(--text);
      min-width: unset;
    }

    .chip{
      display:inline-flex;
      align-items:center;
      gap:6px;
      background: rgba(255,209,102,0.14);
      border: 1px solid var(--accent);
      color: var(--text);
      border-radius: 999px;
      padding: 6px 10px;
      font-weight: 700;
      letter-spacing: .01em;
    }

    .throw-card{ display:grid; gap:14px; }
    .throw-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .checkout-wrap{
      position:sticky;
      top:12px;
      z-index:9;
    }
    .checkout-box{
      background: linear-gradient(135deg, rgba(255,209,102,0.08), rgba(255,255,255,0.04));
      border: 1px solid var(--accent);
      border-radius: 14px;
      padding: 16px 18px;
      display:grid;
      gap:10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .checkout-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      font-size:13px;
      letter-spacing: .02em;
      text-transform: uppercase;
      color: var(--muted);
      font-weight: 700;
    }
    .checkout-main{
      font-size: 28px;
      line-height: 1.2;
      font-weight: 800;
      color: #ffe7a6;
    }
    .checkout-meta{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      font-size:13px;
      color: var(--muted);
    }
    .checkout-badge{
      border:1px solid rgba(255,255,255,0.24);
      padding:4px 8px;
      border-radius: 999px;
      font-weight:700;
    }
    .throw-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(76px, 1fr));
      gap:10px;
    }
    .num-btn{
      background: rgba(255,255,255,0.06);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px 0;
      color: var(--text);
      font-weight: 700;
      letter-spacing: .02em;
      cursor:pointer;
      transition: all .15s ease;
    }
    .num-btn:hover{ border-color: var(--accent); transform: translateY(-1px); }

    .multis{ display:flex; gap:8px; flex-wrap:wrap; }
    .chip-btn{
      background: rgba(255,255,255,0.05);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 999px;
      padding: 8px 12px;
      cursor: pointer;
      font-weight: 700;
      transition: all .15s ease;
    }
    .chip-btn:hover{ border-color: var(--accent); transform: translateY(-1px); }
    .chip-btn.active{
      border-color: var(--accent);
      background: rgba(255,209,102,0.16);
    }

    /* Toast */
    .toast{
      position:fixed;
      left:50%;
      top:50%;
      transform:translate(-50%, -46%);
      background: rgba(0,0,0,0.82);
      color:var(--text);
      padding:14px 18px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.14);
      box-shadow:0 18px 36px rgba(0,0,0,0.5);
      z-index:999;
      pointer-events:none;
      font-weight:800;
      letter-spacing:0.01em;
      font-size:50px;
      opacity:0;
      transition: opacity .2s ease, transform .2s ease;
    }
    .toast.visible{
      opacity:1;
      transform:translate(-50%, -50%);
    }

    .muted{ color:var(--muted); }
    .current-selection{ color:var(--muted); font-size:14px; }
    .turn-info{ font-size:14px; color:var(--muted); }

    .throw-actions{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
      align-items:center;
    }

    .throw-log{ display:grid; gap:8px; transition:max-height .2s ease; }
    .throw-log.collapsed{ display:none; }
    .throw-log.compact .throw-entry:nth-of-type(n+6),
    .throw-log.compact .throw-sep:nth-of-type(n+6){ display:none; }
    .throw-entry{
      display:flex;
      justify-content:space-between;
      align-items:center;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      gap:12px;
      box-shadow:0 10px 24px rgba(0,0,0,0.25);
      animation: fade-in .18s ease;
    }
    .throw-entry .right{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .throw-sep{ border:0; border-top:1px solid var(--border); margin:6px 0; }

    .stats-note{ color:var(--muted); font-size:13px; margin-bottom:8px; }

    /* Celebration */
    .win-overlay{
      position:fixed; inset:0;
      display:grid; place-items:center;
      pointer-events:none;
      z-index:999;
      animation: fade-out 3s ease forwards;
    }
    .win-banner{
      background: rgba(0,0,0,0.35);
      padding: 16px 22px;
      border-radius: 14px;
      border: 1px solid var(--accent);
      color: var(--text);
      font-weight: 800;
      letter-spacing: .03em;
      backdrop-filter: blur(6px);
      box-shadow: 0 12px 40px rgba(0,0,0,0.35);
    }
    .confetti-piece{
      position:fixed;
      top:-10vh;
      width:8px; height:14px;
      background: var(--accent);
      opacity:.85;
      border-radius:2px;
      pointer-events:none;
      z-index:998;
      animation: confetti-fall linear forwards;
    }
    @keyframes confetti-fall{
      0%{ transform: translateY(0) rotate(0deg); }
      100%{ transform: translateY(110vh) rotate(360deg); }
    }
    @keyframes fade-out{
      0%{ opacity:1; }
      100%{ opacity:0; }
    }
    @keyframes fade-in{
      0%{ opacity:0; transform: translateY(6px); }
      100%{ opacity:1; transform: translateY(0); }
    }
    @keyframes pop{
      0%{ transform: translateX(-50%) scale(0.85); opacity:0; }
      70%{ transform: translateX(-50%) scale(1.05); opacity:1; }
      100%{ transform: translateX(-50%) scale(1); opacity:1; }
    }

    .mode-actions{ display:flex; gap:8px; flex-wrap:wrap; margin-top:6px; align-items:center; }

    @media (max-width:700px){
      body{ padding:12px; }
      .page{ gap:14px; }
      .score-header{ flex-direction: column; align-items: stretch; }
      .mode-actions{ width:100%; justify-content:flex-start; }
      .player-form{ width:100%; }
      .player-form > *{ flex:1 1 140px; min-width:140px; }
      .player-grid{ grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
      .throw-card{
        position:sticky;
        bottom:0;
        z-index:10;
        border-radius:18px 18px 0 0;
        box-shadow: 0 -8px 30px rgba(0,0,0,0.45);
      }
      .throw-grid{ grid-template-columns: repeat(auto-fit, minmax(64px, 1fr)); gap:8px; }
      .multis{ width:100%; }
      .multis .chip-btn, .multis .ghost-btn{ flex:1 1 100px; min-width:100px; }
      button, .ghost-btn{ width:100%; }
      .checkout-box{ grid-template-columns:1fr; }
    }
  </style>
</head>

<body>
  <main class="page">
    <header style="text-align:center;">
      <div>
        <h1>Doppel-Dart</h1>
        <p class="tagline">Schnelle Erfassung von Würfen & Punkten</p>
      </div>
    </header>

    <section class="panel score-card">
      <div class="score-header">
        <div>
          <h3 style="margin:0;">Spieler & Spiel</h3>
          <p class="tagline" style="margin-top:4px;">Bis zu 10 Spieler. Modus wählen, Spieler hinzufügen — auch während das Spiel läuft.</p>
          <p class="muted" id="modeInfo" style="margin:6px 0 0;">Modus: 501 (Double-Out)</p>
          <div class="mode-actions">
            <button type="button" class="ghost-btn" id="startGameBtn">Spiel starten</button>
            <button type="button" class="ghost-btn" id="nextRoundBtn">Neue Runde</button>
            <button type="button" class="ghost-btn danger" id="resetAllBtn">Alles zurücksetzen</button>
            <button type="button" class="ghost-btn" id="clearLocalBtn">Lokale Statistik löschen</button>
          </div>
        </div>

        <form id="playerForm" class="player-form">
          <select id="gameMode" name="mode" aria-label="Spielmodus">
            <option value="501" selected>501 (Double-Out)</option>
            <option value="301">301 (Double-Out)</option>
            <option value="atc">Around the Clock</option>
            <option value="shanghai">Shanghai</option>
          </select>
          <input id="playerName" name="name" maxlength="18" placeholder="Name (optional)" />
          <input id="startScore" name="score" type="number" min="0" max="2000" value="501" />
          <button id="addPlayerBtn" type="submit">Spieler hinzufügen</button>
        </form>
      </div>

      <div id="playerBody" class="player-grid">
        <div class="empty muted">Noch keine Spieler hinzugefügt.</div>
      </div>
    </section>

    <section class="panel throw-card">
      <div class="throw-header">
        <div>
          <h3 style="margin:0;">Würfe (1–20 + Bull 25 + 0/Miss)</h3>
          <p class="tagline" style="margin-top:4px;">Multiplikator wählen → Zahl klicken. (Bull: nur Single/Double)</p>
        </div>
        <div class="throw-actions">
          <button id="toggleLogBtn" class="ghost-btn ghost-compact">Historie anzeigen</button>
          <button id="clearThrows" class="ghost-btn">Runde leeren</button>
        </div>
      </div>

      <div class="checkout-wrap">
        <div class="checkout-box" id="checkoutBox"></div>
      </div>

      <div class="multis" id="multiButtons" aria-label="Multiplikator">
        <button type="button" class="chip-btn active" data-mult="1">Single</button>
        <button type="button" class="chip-btn" data-mult="2">Double</button>
        <button type="button" class="chip-btn" data-mult="3">Triple</button>
        <button type="button" class="ghost-btn" id="missBtn">0 (Fehlwurf)</button>
      </div>

      <div class="current-selection" id="currentSelection">Auswahl: Single</div>
      <div class="turn-info" id="turnInfo">Aktiver Spieler: –</div>

      <div class="throw-grid" id="throwNumbers"></div>

      <div class="throw-log" id="throwLog">
        <div class="muted">Noch keine Würfe erfasst.</div>
      </div>
    </section>

    <section class="panel">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
        <div>
          <h3 style="margin:0;">Statistik je Spieler</h3>
          <div class="stats-note" id="statsNote">Darts, Singles/Doubles/Triples, Punkte, Ø Punkte/Dart.</div>
        </div>
      </div>
      <div class="table-wrap">
        <table aria-label="Statistik">
          <thead id="statsHead"></thead>
          <tbody id="statsBody">
            <tr class="empty">
              <td style="text-align:center; color:var(--muted);">Noch keine Daten.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
  </main>

  <!-- Socket optional (nur wenn du Backend wirklich nutzt) -->
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

  <script>
    // ============================================================
    // KONFIG
    // ============================================================
    const API_BASE = "http://localhost:4000";
    let useBackend = true; // <- TRUE nur, wenn du wirklich Backend/Socket hast.
    let backendMatchId = null;
    let backendPlayerMap = {}; // localId -> backendId
    let backendSocket = null;

    const LOCAL_KEY = "dart-local-state-v2";
    const MAX_PLAYERS = 10;
    let lastHatzTurn = null; // Merker für 26 (20/1/5) pro Aufnahme
    let suppressHatzToast = false; // wird bei Re-Simulation deaktiviert

    const MODES = {
      "501": { label: "501 (Double-Out)", start: 501, type: "x01" },
      "301": { label: "301 (Double-Out)", start: 301, type: "x01" },
      "atc": { label: "Around the Clock", start: 0, type: "atc" },
      "shanghai": { label: "Shanghai", start: 0, type: "shanghai" }
    };

    const throwNumbersList = [...Array(20).keys()].map(n => n + 1).concat([25]);

    // ============================================================
    // DOM
    // ============================================================
    const playerForm = document.getElementById("playerForm");
    const playerNameInput = document.getElementById("playerName");
    const startScoreInput = document.getElementById("startScore");
    const playerBody = document.getElementById("playerBody");
    const gameModeSelect = document.getElementById("gameMode");
    const modeInfo = document.getElementById("modeInfo");

    const throwNumbers = document.getElementById("throwNumbers");
    const multiButtons = document.getElementById("multiButtons");
    const currentSelection = document.getElementById("currentSelection");
    const missBtn = document.getElementById("missBtn");
    const throwLog = document.getElementById("throwLog");
    const toggleLogBtn = document.getElementById("toggleLogBtn");
    const clearThrowsBtn = document.getElementById("clearThrows");
    const startGameBtn = document.getElementById("startGameBtn");
    const nextRoundBtn = document.getElementById("nextRoundBtn");
    const resetAllBtn = document.getElementById("resetAllBtn");
    const clearLocalBtn = document.getElementById("clearLocalBtn");
    const turnInfo = document.getElementById("turnInfo");
    const checkoutBox = document.getElementById("checkoutBox");

    const statsHead = document.getElementById("statsHead");
    const statsBody = document.getElementById("statsBody");
    const statsNote = document.getElementById("statsNote");

    // ============================================================
    // STATE
    // ============================================================
    const state = {
      mode: gameModeSelect.value,

      // neu
      matchStarted: false,  // wurde jemals gestartet?
      legEnded: false,      // gerade zwischen zwei Legs?

      running: false,

      players: [], // {id,name,score,legs,sets}
      throws: [],  // {id, playerId, num, mult, score, turn, dartInTurn, bust?, finishAttempt?, hitFlag?}
      statsTotals: {}, // playerId -> {darts,singles,doubles,triples,points}

      currentPlayerIndex: 0,
      dartsInTurn: 0,
      globalTurnCounter: 1,
      turnSnapshot: null, // snapshot per turn (bust/Shanghai S/D/T)

      // mode-specific
      atcTargetIndex: {},  // playerId -> 0..20 (20 => Bull)
      shanghaiRound: 1,     // 1..20
      shanghaiPoints: {},   // playerId -> points
    };

    // ============================================================
    // UTIL
    // ============================================================
    const createId = () => {
      return (typeof crypto !== "undefined" && crypto.randomUUID)
        ? crypto.randomUUID()
        : "id-" + Math.random().toString(16).slice(2);
    };

    const backendEnabled = () => useBackend && typeof io !== "undefined";

    const ensureBackendSocket = () => {
      if (!backendEnabled()) return null;
      if (backendSocket) return backendSocket;
      backendSocket = io(API_BASE);
      backendSocket.on("connect", () => console.log("Socket verbunden"));
      backendSocket.on("connect_error", (err) => console.warn("Socket Fehler", err));
      backendSocket.on("match_state", (payload) => applyBackendState(payload));
      backendSocket.on("match_created", (payload) => applyBackendState(payload));
      backendSocket.on("throw_added", ({ entry, match }) => applyBackendEntry(entry, match));
      return backendSocket;
    };

    function mapBackendPlayers(backendPlayers){
      // Backend ist Quelle der Wahrheit für IDs/Scores/Legs/Sets
      const mapped = backendPlayers.map((bp) => ({
        id: bp.id,
        name: bp.name,
        score: bp.score,
        legs: bp.legs || 0,
        sets: bp.sets || 0
      }));
      backendPlayerMap = {}; // nicht mehr nötig, aber leeren
      state.players = mapped;
    }

    function applyBackendEntry(entry, match){
      if (!entry || !match) return;
      backendMatchId = match.id || backendMatchId;
      mapBackendPlayers(match.players || []);
      state.currentPlayerIndex = match.currentIndex ?? 0;
      state.globalTurnCounter = match.currentTurn ?? state.globalTurnCounter ?? 1;
      state.dartsInTurn = match.dartsInTurn ?? 0;
      state.running = true;
      state.legEnded = false;

      // dedupe by entry.id
      if (!state.throws.some(t => t.id === entry.id)){
        const dartInTurn = (() => {
          const sameTurn = state.throws.filter(t => t.turn === entry.turn && t.playerId === entry.playerId).length;
          return sameTurn + 1;
        })();
        state.throws.push({
          id: entry.id,
          playerId: entry.playerId,
          num: entry.value,
          mult: entry.mult,
          score: entry.score,
          turn: entry.turn,
          dartInTurn
        });
      }

      if (entry.dartInTurn === 3) maybeTriggerHatz(entry.turn);

      // Stats neu aufbauen
      state.statsTotals = {};
      state.players.forEach(pl => ensureStats(pl.id));
      state.throws.forEach(t => accumulateStats(t.playerId, t.mult, t.score));

      state.turnSnapshot = snapshotTurnForCurrentPlayer();
      renderAll();
      saveLocalState();
    }

    function applyBackendState(payload){
      if (!payload) return;
      const match = payload.match || payload;
      if (!match) return;
      backendMatchId = match.id || backendMatchId;
      mapBackendPlayers(match.players || []);
      state.currentPlayerIndex = match.currentIndex ?? 0;
      state.globalTurnCounter = match.currentTurn ?? state.globalTurnCounter ?? 1;
      state.dartsInTurn = match.dartsInTurn ?? 0;
      state.running = true;
      state.legEnded = false;

      const backendThrows = payload.throws || [];
      state.throws = backendThrows.map((e, idx) => {
        const dartInTurn = e.dartInTurn ?? (() => {
          const before = backendThrows.slice(0, idx).filter(t => t.turn === e.turn && t.playerId === e.playerId).length;
          return before + 1;
        })();
        return {
          id: e.id || createId(),
          playerId: e.playerId,
          num: e.value,
          mult: e.mult,
          score: e.score,
          turn: e.turn,
          dartInTurn
        };
      });

      // Scores/Legs/Sets schon im Match enthalten
      state.players = state.players.map(p => {
        const bp = (match.players || []).find(x => x.id === p.id);
        if (!bp) return p;
        return { ...p, score: bp.score, legs: bp.legs || 0, sets: bp.sets || 0 };
      });

      // Stats neu aufbauen
      state.statsTotals = {};
      state.players.forEach(pl => ensureStats(pl.id));
      state.throws.forEach(t => accumulateStats(t.playerId, t.mult, t.score));

      state.turnSnapshot = snapshotTurnForCurrentPlayer();

      renderAll();
      saveLocalState();
    }

    async function backendCreateMatch(){
      if (!backendEnabled()) return;
      try{
        const res = await fetch(`${API_BASE}/api/match`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ mode: state.mode, players: state.players.map(p => p.name) })
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        backendMatchId = data.id || data.match?.id || null;
        const backendPlayers = data.players || data.match?.players || [];
        if (backendPlayers.length) mapBackendPlayers(backendPlayers);
        ensureBackendSocket();
        applyBackendState(data);
      } catch (err){
        console.warn("Backend-Match konnte nicht erstellt werden:", err);
        showToast("Backend nicht erreichbar – spiele lokal weiter.");
      }
    }

    async function backendSendThrow(localPlayerId, num, mult, apply = false){
      if (!backendEnabled() || !backendMatchId) return null;
      const backendPlayerId = localPlayerId; // IDs sind identisch zu Backend
      try{
        const res = await fetch(`${API_BASE}/api/match/throw`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ playerId: backendPlayerId, value: num, mult })
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        if (apply && data) applyBackendEntry(data.entry, data.match);
        return data;
      } catch (err){
        console.warn("Backend-Throw fehlgeschlagen:", err);
        showToast("Backend nicht erreichbar – Wurf nur lokal.");
        return null;
      }
    }

    const clampScore = (value, fallback) => {
      const n = Number(value);
      return Number.isFinite(n) ? Math.max(0, Math.min(2000, n)) : fallback;
    };

    function labelForMultiplier(m){
      if (m === 1) return "Single";
      if (m === 2) return "Double";
      return "Triple";
    }

    function isValidTriple(num){ return num >= 1 && num <= 20; }

    function computeScore(num, mult){
      if (num === 25 && mult === 2) return 50;
      if (num === 25 && mult === 1) return 25;
      return num * mult;
    }

    function isFinishingDouble(num, mult){
      if (num === 25 && mult === 2) return true; // Double Bull
      return mult === 2;
    }

    function showToast(message, extraClass = ""){
      const toast = document.createElement("div");
      toast.className = "toast";
      if (extraClass) toast.classList.add(extraClass);
      toast.textContent = message;
      document.body.appendChild(toast);
      requestAnimationFrame(() => toast.classList.add("visible"));
      const VISIBLE_MS = 10000;
      setTimeout(() => toast.classList.remove("visible"), VISIBLE_MS);
      setTimeout(() => toast.remove(), VISIBLE_MS + 800);
    }

    function maybeTriggerHatz(turnNumber){
      if (suppressHatzToast) return;
      if (lastHatzTurn === turnNumber) return;
      const entries = state.throws.filter(t => t.turn === turnNumber);
      if (entries.length < 3) return; // klassische 3-Dart-Aufnahme
      if (entries.some(t => t.bust)) return; // Bust-Turn zählt nicht
      const sum = entries.reduce((s,t)=>s+t.score,0);
      if (sum === 26){
        lastHatzTurn = turnNumber;
        showToast("Hat's Gschmeckt?");
      }
    }

    function getMode(){ return MODES[state.mode]; }

    function getATCTargetForPlayer(playerId){
      const idx = (state.atcTargetIndex[playerId] != null) ? state.atcTargetIndex[playerId] : 0;
      if (idx <= 19) return idx + 1; // 1..20
      return 25; // Bull
    }

    // Checkout-Empfehlung für Double-Out (x01), max. 3 Darts, endet immer auf Double.
    function suggestCheckout(score) {
      // Nicht checkbare Restwerte in 3 Darts (DO-Regel)
      const impossible = new Set([169, 168, 166, 165, 163, 162, 159]);
      if (score > 170) return "Unter 170 kommen, dann Checkout spielen.";
      if (impossible.has(score)) return "Kein Checkout möglich";
      if (score === 0) return "Ausgecheckt!";

      // Bevorzugt hohe Felder (T20/T19) und bekannte Routen; immer Double zum Schluss.
      const chart = {
        170:"T20, T20, D25",
        167:"T20, T19, D25", 164:"T20, T18, D25", 161:"T20, T17, D25",
        160:"T20, T20, D20", 158:"T20, T20, D19", 157:"T20, T19, D20", 156:"T20, T20, D18",
        155:"T20, T19, D19", 154:"T20, T18, D20", 153:"T20, T19, D18", 152:"T20, T20, D16",
        151:"T20, T17, D20", 150:"T20, T18, D18", 149:"T20, T19, D16", 148:"T20, T16, D20",
        147:"T20, T17, D18", 146:"T20, T18, D16", 145:"T20, T15, D20", 144:"T20, T20, D12",
        143:"T20, T17, D16", 142:"T20, T14, D20", 141:"T20, T19, D12", 140:"T20, T20, D10",
        139:"T20, T13, D20", 138:"T20, T18, D12", 137:"T20, T19, D10", 136:"T20, T20, D8",
        135:"T20, T17, D12", 134:"T20, T14, D16", 133:"T20, T19, D8",  132:"T20, T16, D12",
        131:"T20, T13, D16", 130:"T20, T20, D5",  129:"T19, T16, D12", 128:"T18, T14, D16",
        127:"T20, T17, D8",  126:"T19, T19, D6",  125:"T18, T13, D16", 124:"T20, T16, D8",
        123:"T19, T16, D9",  122:"T18, T20, D4",  121:"T20, T11, D14",
        120:"T20, S20, D20", 119:"T19, T12, D13", 118:"T20, S18, D20", 117:"T20, S17, D20",
        116:"T20, S16, D20", 115:"T20, S15, D20", 114:"T20, S14, D20", 113:"T20, S13, D20",
        112:"T20, S12, D20", 111:"T20, S19, D16", 110:"T20, S10, D20", 109:"T20, S9, D20",
        108:"T20, S16, D16", 107:"T19, S10, D20", 106:"T20, S6, D20",  105:"T20, S13, D16",
        104:"T18, S18, D16", 103:"T20, S3, D20",  102:"T20, S10, D16", 101:"T17, S18, D16",
        100:"T20, D20",
         99:"T19, S10, D16",  98:"T20, D19",  97:"T19, D20",  96:"T20, D18",
         95:"T19, D19",  94:"T18, D20",  93:"T19, D18",  92:"T20, D16",
         91:"T17, D20",  90:"T18, D18",  89:"T19, D16",  88:"T16, D20",
         87:"T17, D18",  86:"T18, D16",  85:"T15, D20",  84:"T20, D12",
         83:"T17, D16",  82:"Bull, D16",  81:"T19, D12",  80:"T20, D10",
         79:"T19, D11",  78:"T18, D12",  77:"T19, D10",  76:"T20, D8",
         75:"T17, D12",  74:"T14, D16",  73:"T19, D8",   72:"T16, D12",
         71:"T13, D16",  70:"T18, D8",   69:"T19, D6",   68:"T20, D4",
         67:"T17, D8",   66:"T10, D18",  65:"T15, D10",  64:"T16, D8",
         63:"T13, D12",  62:"T10, D16",  61:"T15, D8",   60:"S20, D20",
         59:"S19, D20",  58:"S18, D20",  57:"S17, D20",  56:"S16, D20",
         55:"S15, D20",  54:"S14, D20",  53:"S13, D20",  52:"S20, D16",
         51:"S19, D16",  50:"D25",       49:"S17, D16",  48:"S16, D16",
         47:"S15, D16",  46:"S6, D20",   45:"S13, D16",  44:"S12, D16",
         43:"S11, D16",  42:"S10, D16",  41:"S9, D16",   40:"D20",
         38:"D19", 36:"D18", 34:"D17", 32:"D16", 30:"D15", 28:"D14", 26:"D13",
         24:"D12", 22:"D11", 20:"D10", 18:"D9", 16:"D8", 14:"D7", 12:"D6", 10:"D5",
          8:"D4", 6:"D3", 4:"D2", 2:"D1"
      };

      // Fallback: gerade Rest ≤ 40 → direktes Double.
      if (chart[score]) return chart[score];
      if (score <= 40 && score % 2 === 0) return `D${score / 2}`;

      return "Kein Checkout möglich";
    }

    // ============================================================
    // LOCAL PERSISTENCE (nur Offline)
    // ============================================================
    function saveLocalState(){
      if (useBackend) return;
      try {
        const payload = {
          v: 2,
          mode: state.mode,
          matchStarted: state.matchStarted,
          legEnded: state.legEnded,
          running: state.running,
          players: state.players,
          throws: state.throws,
          statsTotals: state.statsTotals,
          currentPlayerIndex: state.currentPlayerIndex,
          dartsInTurn: state.dartsInTurn,
          globalTurnCounter: state.globalTurnCounter,
          turnSnapshot: state.turnSnapshot,
          atcTargetIndex: state.atcTargetIndex,
          shanghaiRound: state.shanghaiRound,
          shanghaiPoints: state.shanghaiPoints
        };
        localStorage.setItem(LOCAL_KEY, JSON.stringify(payload));
      } catch (e) {
        console.warn("Local save failed:", e);
      }
    }

    function loadLocalState(){
      if (useBackend) return;
      try {
        const raw = localStorage.getItem(LOCAL_KEY);
        if (!raw) return;
        const data = JSON.parse(raw);
        if (!data || data.v !== 2) return;

        state.mode = data.mode || state.mode;
        state.matchStarted = !!data.matchStarted;
        state.legEnded = !!data.legEnded;
        state.running = !!data.running;
        state.players = Array.isArray(data.players) ? data.players : [];
        state.throws = Array.isArray(data.throws) ? data.throws : [];
        state.statsTotals = data.statsTotals || {};
        state.currentPlayerIndex = data.currentPlayerIndex || 0;
        state.dartsInTurn = data.dartsInTurn || 0;
        state.globalTurnCounter = data.globalTurnCounter || 1;
        state.turnSnapshot = data.turnSnapshot || null;
        state.atcTargetIndex = data.atcTargetIndex || {};
        state.shanghaiRound = data.shanghaiRound || 1;
        state.shanghaiPoints = data.shanghaiPoints || {};

        gameModeSelect.value = state.mode;
        renderAll();
      } catch (e) {
        console.warn("Local load failed:", e);
      }
    }

    function clearLocalState(){
      if (useBackend) return;
      localStorage.removeItem(LOCAL_KEY);
      hardResetButKeepPlayers(false);
    }

    async function backendLoadMatch(){
      if (!backendEnabled()) return;
      try{
        const res = await fetch(`${API_BASE}/api/match`);
        if (!res.ok){
          if (res.status !== 404) console.warn("Backend Match GET HTTP", res.status);
          return;
        }
        const data = await res.json();
        applyBackendState(data);
        ensureBackendSocket();
      } catch (err){
        console.warn("Backend Match GET Fehler:", err);
      }
    }

    // ============================================================
    // CELEBRATION
    // ============================================================
    function triggerWinCelebration(text){
      const overlay = document.createElement("div");
      overlay.className = "win-overlay";
      const banner = document.createElement("div");
      banner.className = "win-banner";
      banner.textContent = text;
      overlay.appendChild(banner);
      document.body.appendChild(overlay);

      const colors = ["#ffd166","#ff9f1c","#f7eef2","#e0c9d4"];
      for (let i=0;i<80;i++){
        const piece = document.createElement("div");
        piece.className = "confetti-piece";
        piece.style.left = `${Math.random()*100}vw`;
        piece.style.background = colors[i % colors.length];
        const duration = 2 + Math.random()*1.5;
        const delay = Math.random()*0.2;
        piece.style.animationDuration = `${duration}s`;
        piece.style.animationDelay = `${delay}s`;
        document.body.appendChild(piece);
        setTimeout(() => piece.remove(), (duration + delay)*1000 + 200);
      }
      setTimeout(() => overlay.remove(), 3000);
    }

    // ============================================================
    // MULTIPLIER UI
    // ============================================================
    let selectedMultiplier = 1;

    function renderMultiplierUI(){
      multiButtons.querySelectorAll(".chip-btn").forEach(btn => {
        const mult = Number(btn.dataset.mult);
        btn.classList.toggle("active", mult === selectedMultiplier);
      });
      currentSelection.textContent = `Auswahl: ${labelForMultiplier(selectedMultiplier)}`;
    }

    multiButtons.addEventListener("click", (e) => {
      const btn = e.target.closest(".chip-btn");
      if (!btn) return;
      selectedMultiplier = Number(btn.dataset.mult) || 1;
      renderMultiplierUI();
    });

    // ============================================================
    // PLAYER + INIT FOR MODE
    // ============================================================
    function ensureStats(playerId){
      if (!state.statsTotals[playerId]){
        state.statsTotals[playerId] = { darts:0, singles:0, doubles:0, triples:0, points:0 };
      }
    }

    function initPlayerForCurrentMode(player){
      const m = getMode();
      ensureStats(player.id);

      if (m.type === "x01"){
        player.score = m.start;
      } else if (m.type === "atc"){
        state.atcTargetIndex[player.id] = 0;
      } else {
        state.shanghaiPoints[player.id] = 0;
      }
    }

    function createPlayer(name){
      const m = getMode();

      // Wenn Spiel läuft: x01 Startscore IMMER m.start (dein Wunsch)
      // Wenn Spiel NICHT läuft: du darfst im UI startScoreInput nutzen
      const start = (m.type === "x01")
        ? (state.running ? m.start : clampScore(startScoreInput.value, m.start))
        : 0;

      return {
        id: createId(),
        name,
        score: start,
        legs: 0,
        sets: 0
      };
    }

    function removePlayer(playerId){
      const idx = state.players.findIndex(p => p.id === playerId);
      if (idx === -1) return;

      state.players.splice(idx, 1);
      delete state.statsTotals[playerId];
      delete state.atcTargetIndex[playerId];
      delete state.shanghaiPoints[playerId];

      state.throws = state.throws.filter(t => t.playerId !== playerId);

      if (state.currentPlayerIndex >= state.players.length) state.currentPlayerIndex = 0;
      recomputeFromThrows(); // hält Spiel konsistent
    }

    // Reset einzelner Spieler: nur wenn NICHT running (wird auch UI-disabled)
    function resetPlayer(playerId){
      const p = state.players.find(x => x.id === playerId);
      if (!p) return;

      initPlayerForCurrentMode(p);
      state.throws = state.throws.filter(t => t.playerId !== playerId);
      state.statsTotals[playerId] = { darts:0, singles:0, doubles:0, triples:0, points:0 };

      // Turn state sauber setzen (falls Spieler aktuell war)
      state.currentPlayerIndex = 0;
      state.dartsInTurn = 0;
      state.globalTurnCounter = 1;
      state.turnSnapshot = snapshotTurnForCurrentPlayer();

      recomputeFromThrows();
    }

    // ============================================================
    // TURN / ROUND CONTROL
    // ============================================================
    function snapshotTurnForCurrentPlayer(){
      const p = state.players[state.currentPlayerIndex];
      const m = getMode();
      if (!p) return null;

      if (m.type === "x01"){
        return { score: p.score };
      }
      if (m.type === "atc"){
        return { targetIndex: state.atcTargetIndex[p.id] ?? 0 };
      }
      // Shanghai: track s/d/t hits within this turn for current round
      return { s:false, d:false, t:false };
    }

    function advancePlayer(){
      if (!state.players.length) return;
      state.currentPlayerIndex = (state.currentPlayerIndex + 1) % state.players.length;
      state.dartsInTurn = 0;
      state.globalTurnCounter += 1;
      state.turnSnapshot = snapshotTurnForCurrentPlayer();
    }

    function endTurn(){
      const turnNumber = state.globalTurnCounter;
      maybeTriggerHatz(turnNumber);
      const m = getMode();
      advancePlayer();

      if (m.type === "shanghai"){
        if (state.currentPlayerIndex === 0){
          state.shanghaiRound += 1;
          if (state.shanghaiRound > 20){
            // winner by points
            const winner = state.players
              .map(p => ({ p, pts: state.shanghaiPoints[p.id] ?? 0 }))
              .sort((a,b) => b.pts - a.pts)[0];
            triggerWinCelebration(`Shanghai Ende! Gewinner: ${winner.p.name} (${winner.pts} Punkte)`);
            startLegFresh(); // neues Leg
            return;
          }
        }
        state.turnSnapshot = snapshotTurnForCurrentPlayer();
      }
    }

    function bustCurrentTurn(){
      const p = state.players[state.currentPlayerIndex];
      const m = getMode();
      const snap = state.turnSnapshot;
      if (!p || !snap) return;

      if (m.type === "x01"){
        p.score = snap.score;
      }
      endTurn();
    }

    function startLegFresh(){
      const m = getMode();

      // Leg läuft jetzt
      state.matchStarted = true;
      state.running = true;
      state.legEnded = false;
      lastHatzTurn = null; // Hatz-Toast für neues Leg zurücksetzen

      // Leg-Log leeren (Stats bleiben über Match erhalten)
      state.throws.length = 0;

      // StatsTotals NICHT löschen (cumulative). Nur sicherstellen, dass jeder Spieler einen Eintrag hat.
      state.players.forEach(p => ensureStats(p.id));

      // mode-specific reset fürs neue Leg
      if (m.type === "x01"){
        state.players.forEach(p => { p.score = m.start; });
      } else if (m.type === "atc"){
        // ATC pro Leg neu
        state.atcTargetIndex = {};
        state.players.forEach(p => state.atcTargetIndex[p.id] = 0);
      } else {
        // Shanghai pro Leg neu
        state.shanghaiRound = 1;
        state.shanghaiPoints = {};
        state.players.forEach(p => state.shanghaiPoints[p.id] = 0);
      }

      state.currentPlayerIndex = 0;
      state.dartsInTurn = 0;
      state.globalTurnCounter = 1;
      state.turnSnapshot = snapshotTurnForCurrentPlayer();

      renderAll();
      saveLocalState();
    }

    async function startGame(){
      if (!state.players.length){
        alert("Bitte zuerst Spieler anlegen.");
        return;
      }

      state.mode = gameModeSelect.value;

      if (useBackend){
        if (!backendMatchId){
          await backendCreateMatch();
        } else {
          await backendLoadMatch(); // aktuellen Stand holen
        }
      }

      // Wenn Match schon gestartet war und nur pausiert ist (legEnded), starten wir das nächste Leg:
      startLegFresh();
    }

    async function nextRound(){
      if (!state.players.length) return;

      // Starter rotieren: erster Spieler ans Ende
      const first = state.players.shift();
      state.players.push(first);

      if (useBackend && !backendMatchId){
        await backendCreateMatch();
      }

      startLegFresh();
    }

    function hardResetButKeepPlayers(keepPlayers = true){
      // alles resetten, optional Spieler behalten
      state.matchStarted = false;
      state.legEnded = false;
      state.running = false;
      state.throws.length = 0;
      state.statsTotals = {};

      state.atcTargetIndex = {};
      state.shanghaiPoints = {};
      state.shanghaiRound = 1;

      state.currentPlayerIndex = 0;
      state.dartsInTurn = 0;
      state.globalTurnCounter = 1;
      state.turnSnapshot = null;

      if (!keepPlayers){
        state.players = [];
      } else {
        // Sets/Legs zurücksetzen und Scores passend zum Modus
        const m = getMode();
        state.players.forEach(p => {
          p.legs = 0; p.sets = 0;
          ensureStats(p.id);
          if (m.type === "x01") p.score = m.start;
          if (m.type === "atc") state.atcTargetIndex[p.id] = 0;
          if (m.type === "shanghai") state.shanghaiPoints[p.id] = 0;
        });
      }

      renderAll();
      saveLocalState();
    }

    // ============================================================
    // THROW / STATS
    // ============================================================
    function accumulateStats(playerId, mult, score){
      ensureStats(playerId);
      const s = state.statsTotals[playerId];
      s.darts += 1;
      if (mult === 1) s.singles += 1;
      else if (mult === 2) s.doubles += 1;
      else if (mult === 3) s.triples += 1;
      s.points += score;
    }

    // Leg-Ende pausieren
    function endLeg(winnerName){
      state.running = false;
      state.legEnded = true;

      triggerWinCelebration(`Leg gewonnen: ${winnerName}!`);

      renderAll();
      saveLocalState();
    }

    function recordThrow(playerId, num, mult){
      // normalize constraints
      if (num === 25 && mult === 3) mult = 2;
      if (mult === 3 && !isValidTriple(num)) mult = 2;

      const score = (num === 0) ? 0 : computeScore(num, mult);

      const entry = {
        id: createId(),
        playerId,
        num,
        mult,
        score,
        turn: state.globalTurnCounter,
        dartInTurn: state.dartsInTurn + 1
      };
      state.throws.push(entry);
      accumulateStats(playerId, mult, score);
      return entry;
    }

    async function addThrow(num){
      if (!state.players.length){
        alert("Bitte zuerst Spieler anlegen.");
        return;
      }
      if (!state.running){
        if (state.legEnded){
          alert("Leg ist beendet. Drücke „Neue Runde“, um das nächste Leg zu starten.");
        } else {
          alert("Bitte erst „Spiel starten“ drücken.");
        }
        return;
      }

      const p = state.players[state.currentPlayerIndex];
      const m = getMode();

      // Miss
      if (num === 0){
        if (useBackend){
          await backendSendThrow(p.id, 0, 1, true);
        } else {
          recordThrow(p.id, 0, 1);
          state.dartsInTurn += 1;
          if (state.dartsInTurn >= 3) endTurn();
          renderAll(); saveLocalState();
        }
        return;
      }

      // multiplier selection with constraints
      let mult = selectedMultiplier || 1;
      if (num === 25 && mult === 3) mult = 2;
      if (mult === 3 && !isValidTriple(num)) mult = 2;

      if (useBackend){
        await backendSendThrow(p.id, num, mult, true);
        return;
      }

      const entry = recordThrow(p.id, num, mult);

      // --- apply mode rules ---
      if (m.type === "x01"){
        // snapshot if missing
        if (!state.turnSnapshot) state.turnSnapshot = snapshotTurnForCurrentPlayer();

        const newScore = p.score - entry.score;

        if (newScore < 0 || newScore === 1){
          entry.bust = true;
          bustCurrentTurn();
          renderAll(); saveLocalState();
          selectedMultiplier = 1; renderMultiplierUI();
          return;
        }

        if (newScore === 0){
          if (!isFinishingDouble(num, mult)){
            entry.bust = true;
            entry.finishAttempt = true;
            bustCurrentTurn();
            renderAll(); saveLocalState();
            selectedMultiplier = 1; renderMultiplierUI();
            return;
          }

          // WIN
          maybeTriggerHatz(state.globalTurnCounter);
          p.legs = (p.legs || 0) + 1;
          if (p.legs >= 3){
            p.sets = (p.sets || 0) + 1;
            state.players.forEach(pl => pl.legs = 0);
          }
          p.score = 0;

          // Winner soll nächstes Leg anfangen: an den Anfang schieben
          state.players = [p, ...state.players.filter(x => x.id !== p.id)];

          // Leg pausieren statt automatisch neu starten:
          endLeg(p.name);

          selectedMultiplier = 1;
          renderMultiplierUI();
          return;
        }

        p.score = newScore;

        state.dartsInTurn += 1;
        if (state.dartsInTurn >= 3) endTurn();

        renderAll(); saveLocalState();
        selectedMultiplier = 1; renderMultiplierUI();
        return;
      }

      if (m.type === "atc"){
        const target = getATCTargetForPlayer(p.id);
        const hit = (target === 25) ? (num === 25) : (num === target);

        if (hit){
          entry.hitFlag = true;
          state.atcTargetIndex[p.id] = (state.atcTargetIndex[p.id] ?? 0) + 1;

          if ((state.atcTargetIndex[p.id] ?? 0) >= 21){
            p.legs = (p.legs || 0) + 1;
            triggerWinCelebration(`ATC: ${p.name} hat gewonnen!`);
            startLegFresh();
            selectedMultiplier = 1; renderMultiplierUI();
            return;
          }
        }

        state.dartsInTurn += 1;
        if (state.dartsInTurn >= 3) endTurn();

        renderAll(); saveLocalState();
        selectedMultiplier = 1; renderMultiplierUI();
        return;
      }

      // Shanghai
      if (m.type === "shanghai"){
        const round = state.shanghaiRound;

        // snapshot holds s/d/t flags for THIS player turn
        if (!state.turnSnapshot || typeof state.turnSnapshot.s !== "boolean"){
          state.turnSnapshot = snapshotTurnForCurrentPlayer();
        }

        if (num === round){
          entry.hitFlag = true;
          state.shanghaiPoints[p.id] = (state.shanghaiPoints[p.id] ?? 0) + entry.score;

          if (mult === 1) state.turnSnapshot.s = true;
          if (mult === 2) state.turnSnapshot.d = true;
          if (mult === 3) state.turnSnapshot.t = true;

          if (state.turnSnapshot.s && state.turnSnapshot.d && state.turnSnapshot.t){
            p.legs = (p.legs || 0) + 1;
            if (p.legs >= 3){
              p.sets = (p.sets || 0) + 1;
              state.players.forEach(pl => pl.legs = 0);
            }
            triggerWinCelebration(`Shanghai! ${p.name} gewinnt in Runde ${round}!`);
            startLegFresh();
            selectedMultiplier = 1; renderMultiplierUI();
            return;
          }
        }

        state.dartsInTurn += 1;
        if (state.dartsInTurn >= 3) endTurn();

        renderAll(); saveLocalState();
        selectedMultiplier = 1; renderMultiplierUI();
        return;
      }
    }

    // ============================================================
    // EDIT / DELETE THROWS
    // ============================================================
    function editThrow(index){
      const t = state.throws[index];
      if (!t) return;

      const newNumStr = prompt("Neue Zahl (0–20 oder 25 für Bull):", String(t.num));
      if (newNumStr === null) return;
      const newNum = Number(newNumStr);
      const allowedNums = [0, 25, ...Array.from({length:20},(_,i)=>i+1)];
      if (!Number.isFinite(newNum) || !allowedNums.includes(newNum)){
        alert("Bitte 0–20 oder 25 eingeben.");
        return;
      }

      const newMultStr = prompt("Neuer Multiplikator (1=Single, 2=Double, 3=Triple):", String(t.mult));
      if (newMultStr === null) return;
      const newMult = Number(newMultStr);
      if (![1,2,3].includes(newMult)){
        alert("Multiplikator 1/2/3 wählen.");
        return;
      }

      if (newNum === 25 && newMult === 3){
        alert("Triple Bull gibt es nicht. Nutze Single oder Double.");
        return;
      }
      if (newMult === 3 && !isValidTriple(newNum)){
        alert("Triple nur bei 1–20 erlaubt.");
        return;
      }

      t.num = newNum;
      t.mult = newMult;

      recomputeFromThrows();
      renderAll(); saveLocalState();
    }

    function recomputeFromThrows(){
      const prevSuppress = suppressHatzToast;
      suppressHatzToast = true; // keine Toasts beim Re-Sim
      try {
        // Re-simulate everything from the current throw list (offline)
        if (!state.players.length) return;

        const m = getMode();

        // Keep players and their legs/sets, but recompute scores/points/progress from scratch within current leg
        // (Throws are only for the current leg anyway in this UI)
        const legsSets = state.players.map(p => ({ id:p.id, legs:p.legs||0, sets:p.sets||0, name:p.name }));
        const preservedPlayers = [...state.players];

        // Reset core
        state.statsTotals = {};
        preservedPlayers.forEach(p => ensureStats(p.id));

        state.currentPlayerIndex = 0;
        state.dartsInTurn = 0;
        state.globalTurnCounter = 1;
        state.turnSnapshot = null;
        state.running = true;

        // Mode-specific reset
        if (m.type === "x01"){
          preservedPlayers.forEach(p => p.score = m.start);
        }
        if (m.type === "atc"){
          state.atcTargetIndex = {};
          preservedPlayers.forEach(p => state.atcTargetIndex[p.id] = 0);
        }
        if (m.type === "shanghai"){
          state.shanghaiRound = 1;
          state.shanghaiPoints = {};
          preservedPlayers.forEach(p => state.shanghaiPoints[p.id] = 0);
        }

        // Restore legs/sets
        preservedPlayers.forEach(p => {
          const ls = legsSets.find(x => x.id === p.id);
          if (ls){ p.legs = ls.legs; p.sets = ls.sets; }
        });

        state.players = preservedPlayers;
        state.turnSnapshot = snapshotTurnForCurrentPlayer();

        // Rebuild throws by simulating their order
        const originalThrows = [...state.throws];
        state.throws = [];

        for (let i=0; i<originalThrows.length; i++){
          const t = originalThrows[i];
          const playerIndex = state.players.findIndex(p => p.id === t.playerId);
          if (playerIndex === -1) continue;

          // Rotate until current player matches t.playerId
          while (state.players[state.currentPlayerIndex]?.id !== t.playerId){
            endTurn();
          }

          // Record same throw (re-normalize)
          const entry = recordThrow(t.playerId, t.num, t.mult);

          // Copy intent (then we re-calc flags below)
          // Apply mode logic
          const p = state.players[state.currentPlayerIndex];

          if (m.type === "x01"){
            if (!state.turnSnapshot) state.turnSnapshot = snapshotTurnForCurrentPlayer();

            if (entry.num === 0){
              state.dartsInTurn += 1;
              if (state.dartsInTurn >= 3) endTurn();
              continue;
            }

            const newScore = p.score - entry.score;

            if (newScore < 0 || newScore === 1){
              entry.bust = true;
              bustCurrentTurn();
              continue;
            }

            if (newScore === 0){
              if (!isFinishingDouble(entry.num, entry.mult)){
                entry.bust = true;
                entry.finishAttempt = true;
                bustCurrentTurn();
                continue;
              }
              // Win: we stop here (everything after is invalid for that leg)
              p.legs = (p.legs || 0) + 1;
              if (p.legs >= 3){
                p.sets = (p.sets || 0) + 1;
                state.players.forEach(pl => pl.legs = 0);
              }
              state.players = [p, ...state.players.filter(x => x.id !== p.id)];
              // After win, leg restarts (clear all throws)
              startLegFresh();
              return;
            }

            p.score = newScore;
            state.dartsInTurn += 1;
            if (state.dartsInTurn >= 3) endTurn();
            continue;
          }

          if (m.type === "atc"){
            if (entry.num === 0){
              state.dartsInTurn += 1;
              if (state.dartsInTurn >= 3) endTurn();
              continue;
            }
            const target = getATCTargetForPlayer(p.id);
            const hit = (target === 25) ? (entry.num === 25) : (entry.num === target);

            if (hit){
              entry.hitFlag = true;
              state.atcTargetIndex[p.id] = (state.atcTargetIndex[p.id] ?? 0) + 1;
              if ((state.atcTargetIndex[p.id] ?? 0) >= 21){
                p.legs = (p.legs || 0) + 1;
                startLegFresh();
                return;
              }
            }

            state.dartsInTurn += 1;
            if (state.dartsInTurn >= 3) endTurn();
            continue;
          }

          // Shanghai
          if (m.type === "shanghai"){
            if (!state.turnSnapshot || typeof state.turnSnapshot.s !== "boolean"){
              state.turnSnapshot = snapshotTurnForCurrentPlayer();
            }

            const round = state.shanghaiRound;

            if (entry.num === 0){
              state.dartsInTurn += 1;
              if (state.dartsInTurn >= 3) endTurn();
              continue;
            }

            if (entry.num === round){
              entry.hitFlag = true;
              state.shanghaiPoints[p.id] = (state.shanghaiPoints[p.id] ?? 0) + entry.score;

              if (entry.mult === 1) state.turnSnapshot.s = true;
              if (entry.mult === 2) state.turnSnapshot.d = true;
              if (entry.mult === 3) state.turnSnapshot.t = true;

              if (state.turnSnapshot.s && state.turnSnapshot.d && state.turnSnapshot.t){
                startLegFresh();
                return;
              }
            }

            state.dartsInTurn += 1;
            if (state.dartsInTurn >= 3) endTurn();
            continue;
          }
        }
      } finally {
        suppressHatzToast = prevSuppress;
      }
    }

    // ============================================================
    // RENDERING
    // ============================================================
    function renderModeInfo(){
      const m = getMode();
      modeInfo.textContent = `Modus: ${m.label}`;

      // UI: Startscore-Feld sinnvoll
      if (m.type === "x01") startScoreInput.value = m.start;
      else startScoreInput.value = 0;

      // Moduswechsel nur wenn nicht running (sonst Chaos)
      gameModeSelect.disabled = state.running;
      startScoreInput.disabled = state.running;
    }

    function renderThrowNumbers(){
      throwNumbers.innerHTML = "";
      throwNumbersList.forEach(num => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "num-btn";
        btn.textContent = (num === 25 ? "25 (Bull)" : String(num));
        btn.addEventListener("click", () => addThrow(num));
        throwNumbers.appendChild(btn);
      });
    }

    function renderTurnInfo(){
      if (!state.players.length){
        turnInfo.textContent = "Aktiver Spieler: –";
        return;
      }
      if (!state.running){
        turnInfo.textContent = "Aktiver Spieler: – (Spiel nicht gestartet)";
        return;
      }

      const p = state.players[state.currentPlayerIndex];
      const dartNo = Math.min(state.dartsInTurn + 1, 3);
      const m = getMode();

      if (m.type === "x01"){
        turnInfo.textContent = `Aktiver Spieler: ${p.name} — Dart ${dartNo}/3 — Rest: ${p.score}`;
      } else if (m.type === "atc"){
        const target = getATCTargetForPlayer(p.id);
        turnInfo.textContent = `Aktiver Spieler: ${p.name} — Dart ${dartNo}/3 — Ziel: ${target === 25 ? "Bull" : target}`;
      } else {
        turnInfo.textContent = `Aktiver Spieler: ${p.name} — Dart ${dartNo}/3 — Runde: ${state.shanghaiRound}`;
      }
    }

    function renderCheckoutBox(){
      const m = getMode();

      // Basis-UI
      const baseEmpty = `
        <div class="checkout-head">
          <span>Checkout</span>
          <span class="checkout-badge">Info</span>
        </div>
        <div class="checkout-main">–</div>
        <div class="checkout-meta">
          <span>Empfehlung: –</span>
          <span>Alternativen: –</span>
          <span>Rest: –</span>
        </div>`;

      if (!state.players.length){
        checkoutBox.innerHTML = baseEmpty;
        return;
      }

      if (!state.running){
        checkoutBox.innerHTML = `
          <div class="checkout-head">
            <span>Checkout</span>
            <span class="checkout-badge">Paused</span>
          </div>
          <div class="checkout-main">Drücke „Spiel starten“</div>
          <div class="checkout-meta">
            <span>Aktiver Spieler: –</span>
            <span>Rest: –</span>
          </div>
        `;
        return;
      }

      const p = state.players[state.currentPlayerIndex];

      if (m.type === "x01"){
        const dartsLeft = Math.max(0, 3 - state.dartsInTurn);
        const suggestion = suggestCheckout(p.score);
        const hasCheckout = p.score <= 170 && suggestion !== "Kein Checkout möglich";
        checkoutBox.innerHTML = `
          <div class="checkout-head">
            <span>Checkout</span>
            <span class="checkout-badge">${hasCheckout ? "Empfehlung" : "Hinweis"}</span>
          </div>
          <div class="checkout-main">
            ${hasCheckout ? suggestion : "Kein Checkout sinnvoll – erst unter 170"}
          </div>
          <div class="checkout-meta">
            <span>Aktiver Spieler: ${p.name}</span>
            <span>Darts übrig: ${dartsLeft}</span>
            <span>Rest: ${p.score}</span>
            <span>Alternativen: ${hasCheckout ? "klassische Wege (T20/T19)" : "–"}</span>
          </div>
        `;
        return;
      }

      if (m.type === "atc"){
        const t = getATCTargetForPlayer(p.id);
        checkoutBox.innerHTML = `
          <div class="checkout-head">
            <span>Aktuelles Ziel</span>
            <span class="checkout-badge">ATC</span>
          </div>
          <div class="checkout-main">${t === 25 ? "Bull" : t}</div>
          <div class="checkout-meta">
            <span>Aktiver Spieler: ${p.name}</span>
            <span>Rest: –</span>
            <span>Hinweis: Triff die Zahlen in Reihenfolge.</span>
          </div>
        `;
        return;
      }

      // shanghai
      const pts = state.shanghaiPoints[p.id] ?? 0;
      checkoutBox.innerHTML = `
        <div class="checkout-head">
          <span>Shanghai</span>
          <span class="checkout-badge">Runde ${state.shanghaiRound}/20</span>
        </div>
        <div class="checkout-main">${pts} Punkte</div>
        <div class="checkout-meta">
          <span>Aktiver Spieler: ${p.name}</span>
          <span>Rest: –</span>
          <span>Hinweis: S+D+T in einer Aufnahme = Sieg.</span>
        </div>
      `;
    }

    function renderPlayers(){
      playerBody.innerHTML = "";

      if (!state.players.length){
        const empty = document.createElement("div");
        empty.className = "empty muted";
        empty.textContent = "Noch keine Spieler hinzugefügt.";
        playerBody.appendChild(empty);
        return;
      }

      const m = getMode();
      // Best-/Worst-Bestimmung anhand gescorter Punkte (erst ab Runde 2)
      let bestId = null, worstId = null, bestPts = -Infinity, worstPts = Infinity;
      if (state.globalTurnCounter > 1){
        state.players.forEach(p => {
          const pts = state.statsTotals[p.id]?.points || 0;
          if (pts > bestPts){ bestPts = pts; bestId = p.id; }
          if (pts < worstPts){ worstPts = pts; worstId = p.id; }
        });
      }
      // Bei Gleichstand oder Runde 1 keine Krone/Larry
      const tieAll = bestPts === worstPts;
      if (tieAll || state.globalTurnCounter <= 1){ bestId = null; worstId = null; }

      state.players.forEach((p, idx) => {
        const card = document.createElement("div");
        card.className = "player-card";
        if (state.running && idx === state.currentPlayerIndex) card.classList.add("active-player");

        const top = document.createElement("div");
        top.className = "player-top";
        const crown = document.createElement("div");
        crown.className = "crown";
        // jetzt umgekehrt: Krone für besten Spieler
        if (!tieAll && p.id === bestId) crown.textContent = "👑";
        const nameEl = document.createElement("div");
        nameEl.className = "player-name";
        // Larry-Titel für schlechtesten Spieler
        nameEl.textContent = (!tieAll && p.id === worstId) ? `${p.name} Larry` : p.name;
        const meta = document.createElement("div");
        meta.className = "player-meta";
        meta.innerHTML = `
          <span class="pill">Sets: ${p.sets || 0}</span>
          <span class="pill">Legs: ${p.legs || 0}</span>
        `;
        top.append(crown, nameEl, meta);

        const playerTurns = new Set(state.throws.filter(t => t.playerId === p.id).map(t => t.turn));
        const bestScore = state.throws.filter(t => t.playerId === p.id).reduce((m, t) => Math.max(m, t.score), 0);
        const darts = state.throws.filter(t => t.playerId === p.id).length;
        const points = state.throws.filter(t => t.playerId === p.id).reduce((sum, t) => sum + t.score, 0);
        // X01-Average: (Gesamtpunkte / Darts) * 3 (3-Dart-Average). Misses zählen als 0.
        const avg = (m.type === "x01")
          ? (darts > 0 ? ((points / darts) * 3).toFixed(1) : "0.0")
          : "–";

        const statusMain = (() => {
          if (m.type === "x01") return `${p.score}`;
          if (m.type === "atc") {
            const t = getATCTargetForPlayer(p.id);
            return `Ziel: ${t === 25 ? "Bull" : t}`;
          }
          return `${state.shanghaiPoints[p.id] ?? 0} P`;
        })();

        const d1Club = (m.type === "x01" && p.score === 2) ? `<span class="pill">D1er CLUB</span>` : "";

        const scoreBlock = document.createElement("div");
        scoreBlock.innerHTML = `
          <div class="big-score">${statusMain}</div>
          <div class="meta-row">
            <span class="pill">Ø ${avg}</span>
            <span class="pill">Runden ${playerTurns.size}</span>
            <span class="pill">Best ${bestScore}</span>
            <span class="pill">${darts} Darts</span>
            ${d1Club}
          </div>
        `;

        const actions = document.createElement("div");
        actions.className = "player-actions";
        const resetBtn = document.createElement("button");
        resetBtn.type = "button";
        resetBtn.className = "ghost-btn";
        resetBtn.textContent = "Reset";
        resetBtn.disabled = state.running;
        resetBtn.title = state.running ? "Während eines laufenden Spiels gesperrt." : "";
        resetBtn.addEventListener("click", () => {
          if (state.running) return;
          resetPlayer(p.id);
          renderAll(); saveLocalState();
        });

        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.className = "ghost-btn danger";
        removeBtn.textContent = "Entfernen";
        removeBtn.disabled = state.running;
        removeBtn.title = state.running ? "Während eines laufenden Spiels gesperrt." : "";
        removeBtn.addEventListener("click", () => {
          if (state.running) return;
          removePlayer(p.id);
          renderAll(); saveLocalState();
        });

        actions.append(resetBtn, removeBtn);

        card.append(top, scoreBlock, actions);
        playerBody.appendChild(card);
      });
    }

    function renderThrowLog(){
      throwLog.innerHTML = "";

      if (!state.throws.length){
        const empty = document.createElement("div");
        empty.className = "muted";
        empty.textContent = "Noch keine Würfe erfasst.";
        throwLog.appendChild(empty);
        return;
      }

      const reversed = [...state.throws].reverse();
      const list = throwLog.classList.contains("compact") ? reversed.slice(0, 5) : reversed;
      list.forEach((t, revIdx) => {
        const originalIndex = state.throws.length - 1 - revIdx;
        const p = state.players.find(x => x.id === t.playerId);
        const who = p ? p.name : "Unbekannt";

        const row = document.createElement("div");
        row.className = "throw-entry";

        const left = document.createElement("div");
        const label = (t.num === 0)
          ? "Miss 0"
          : `${labelForMultiplier(t.mult)} ${t.num === 25 ? "Bull" : t.num}`;
        const flags = [
          t.bust ? "BUST" : null,
          t.finishAttempt ? "Finish?" : null,
          t.hitFlag ? "Treffer" : null
        ].filter(Boolean).map(x => `<span class="chip">${x}</span>`).join(" ");

        left.innerHTML = `
          <div><strong>${label}</strong> = ${t.score} P ${flags ? " " + flags : ""}</div>
          <div class="muted">von ${who} · Turn ${t.turn} · Dart ${t.dartInTurn}</div>
        `;

        const right = document.createElement("div");
        right.className = "right";

        const editBtn = document.createElement("button");
        editBtn.type = "button";
        editBtn.className = "ghost-btn";
        editBtn.textContent = "Ändern";
        editBtn.addEventListener("click", () => editThrow(originalIndex));

        const delBtn = document.createElement("button");
        delBtn.type = "button";
        delBtn.className = "ghost-btn danger";
        delBtn.textContent = "Entfernen";
        delBtn.addEventListener("click", () => {
          state.throws.splice(originalIndex, 1);
          recomputeFromThrows();
          renderAll(); saveLocalState();
        });

        right.append(editBtn, delBtn);
        row.append(left, right);
        throwLog.appendChild(row);

        if (revIdx < list.length - 1){
          const hr = document.createElement("hr");
          hr.className = "throw-sep";
          throwLog.appendChild(hr);
        }
      });
    }

    function renderStats(){
      const m = getMode();

      if (!state.players.length){
        statsHead.innerHTML = "";
        statsBody.innerHTML = `<tr class="empty"><td style="text-align:center; color:var(--muted);">Noch keine Daten.</td></tr>`;
        return;
      }

      if (m.type === "x01"){
        statsNote.textContent = "Darts, Singles/Doubles/Triples, Punkte, Ø Punkte/Dart.";
        statsHead.innerHTML = `
          <tr>
            <th>Name</th><th>Darts</th><th>Singles</th><th>Doubles</th><th>Triples</th><th>Punkte</th><th>Ø</th>
          </tr>
        `;
      } else if (m.type === "atc"){
        statsNote.textContent = "Darts, Treffer aufs Ziel, Fortschritt (0–21).";
        statsHead.innerHTML = `
          <tr>
            <th>Name</th><th>Darts</th><th>Treffer</th><th>Fortschritt</th><th>Aktuelles Ziel</th>
          </tr>
        `;
      } else {
        statsNote.textContent = "Darts, Singles/Doubles/Triples (auf Rundenzahlen), Punkte, Ø Punkte/Dart.";
        statsHead.innerHTML = `
          <tr>
            <th>Name</th><th>Darts</th><th>Singles</th><th>Doubles</th><th>Triples</th><th>Punkte</th><th>Ø</th>
          </tr>
        `;
      }

      // Build stats rows
      statsBody.innerHTML = "";

      state.players.forEach(p => {
        ensureStats(p.id);
        const s = state.statsTotals[p.id];
        const tr = document.createElement("tr");

        if (m.type === "x01"){
          // 3-Dart-Average: (Gesamtpunkte / Darts) * 3. Misses zählen als 0.
          const avg = s.darts ? ((s.points / s.darts) * 3).toFixed(1) : "0.0";
          tr.innerHTML = `
            <td>${p.name}</td>
            <td>${s.darts}</td>
            <td>${s.singles}</td>
            <td>${s.doubles}</td>
            <td>${s.triples}</td>
            <td>${s.points}</td>
            <td>${avg}</td>
          `;
        } else if (m.type === "atc"){
          const hits = state.throws.filter(t => t.playerId === p.id && t.hitFlag).length;
          const prog = state.atcTargetIndex[p.id] ?? 0;
          const target = getATCTargetForPlayer(p.id);
          tr.innerHTML = `
            <td>${p.name}</td>
            <td>${s.darts}</td>
            <td>${hits}</td>
            <td>${prog}/21</td>
            <td>${target === 25 ? "Bull" : target}</td>
          `;
        } else {
          const pts = state.shanghaiPoints[p.id] ?? 0;
          const avg = s.darts ? (pts / s.darts).toFixed(1) : "0.0";
          tr.innerHTML = `
            <td>${p.name}</td>
            <td>${s.darts}</td>
            <td>${s.singles}</td>
            <td>${s.doubles}</td>
            <td>${s.triples}</td>
            <td>${pts}</td>
            <td>${avg}</td>
          `;
        }

        statsBody.appendChild(tr);
      });
    }

    function renderAll(){
      renderModeInfo();
      renderPlayers();
      renderTurnInfo();
      renderCheckoutBox();
      renderThrowLog();
      renderStats();
      renderMultiplierUI();
    }

    // ============================================================
    // UI EVENTS
    // ============================================================
    gameModeSelect.addEventListener("change", () => {
      if (state.running){
        gameModeSelect.value = state.mode;
        return;
      }
      state.mode = gameModeSelect.value;
      renderAll();
      saveLocalState();
    });

    missBtn.addEventListener("click", () => addThrow(0));

    toggleLogBtn.addEventListener("click", () => {
      const isCollapsed = throwLog.classList.toggle("collapsed");
      if (!isCollapsed) throwLog.classList.toggle("compact");
      toggleLogBtn.textContent = isCollapsed ? "Historie anzeigen" : "Historie verbergen";
    });

    clearThrowsBtn.addEventListener("click", () => {
      if (!state.running) return;
      // Runde/Leg leeren, Spieler bleiben
      startLegFresh();
    });

    startGameBtn.addEventListener("click", () => {
      state.mode = gameModeSelect.value;
      startGame();
    });

    nextRoundBtn.addEventListener("click", () => {
      if (!state.players.length) return;
      if (!state.running) {
        // Wenn nicht running: starten wir ganz normal
        startGame();
        return;
      }
      nextRound();
    });

    resetAllBtn.addEventListener("click", () => {
      if (!confirm("Wirklich alles zurücksetzen? (Spieler bleiben, Runde & Log werden gelöscht)")) return;
      hardResetButKeepPlayers(true);
    });

    clearLocalBtn.addEventListener("click", () => {
      if (!confirm("Lokale Statistik löschen? (Offline-Modus)")) return;
      clearLocalState();
    });

    // Spieler hinzufügen: auch während laufendem oder pausiertem Leg (Offline)
    playerForm.addEventListener("submit", (e) => {
      e.preventDefault();

      if (state.players.length >= MAX_PLAYERS){
        alert("Maximal 10 Spieler.");
        return;
      }

      // Modus nur ändern, wenn Match noch nicht gestartet ist
      if (!state.matchStarted) state.mode = gameModeSelect.value;

      // Backend: nach Match-Start nicht erlauben
      if (useBackend && state.matchStarted){
        alert("Im Backend-Modus können Spieler nach Match-Start nicht hinzugefügt werden.");
        return;
      }

      const name = (playerNameInput.value.trim() || `Spieler ${state.players.length + 1}`);
      const m = getMode();

      // Startscore-Regel
      const start = (m.type === "x01")
        ? (state.matchStarted ? m.start : clampScore(startScoreInput.value, m.start))
        : 0;

      const newPlayer = {
        id: createId(),
        name,
        score: start,
        legs: 0,
        sets: 0
      };

      state.players.push(newPlayer);
      ensureStats(newPlayer.id);

      // mode-specific init
      if (m.type === "atc") state.atcTargetIndex[newPlayer.id] = 0;
      if (m.type === "shanghai") state.shanghaiPoints[newPlayer.id] = 0;

      playerNameInput.value = "";

      // currentPlayerIndex NICHT verändern
      renderAll();
      saveLocalState();
    });

    // ============================================================
    // INIT
    // ============================================================
    function init(){
      state.mode = gameModeSelect.value;
      renderThrowNumbers();
      throwLog.classList.add("collapsed", "compact");
      toggleLogBtn.textContent = "Historie anzeigen";
      renderAll();
      renderMultiplierUI();

      if (!useBackend){
        loadLocalState();
      } else {
        ensureBackendSocket();
        backendLoadMatch();
      }
    }

    init();
  </script>
</body>
</html>