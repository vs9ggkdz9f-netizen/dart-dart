<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dart Übersicht</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      color-scheme: light dark;
      --bg:#4b0f1f;
      --panel:#56182b;
      --card:#631d33;
      --border:#7a2a41;
      --text:#f7eef2;
      --muted:#e0c9d4;
      --accent:#ffd166;
      --accent-strong:#ff9f1c;
      font-family:"Inter",system-ui,-apple-system,sans-serif;
    }
    body{
      margin:0;
      min-height:100vh;
      background:
        radial-gradient(circle at 20% 20%, rgba(255,209,102,0.08), transparent 35%),
        radial-gradient(circle at 80% 0%, rgba(255,159,28,0.08), transparent 40%),
        var(--bg);
      color:var(--text);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:32px;
    }
    .page{ width:min(1200px,100%); display:grid; gap:24px; }
    header{ display:flex; align-items:flex-end; justify-content:space-between; gap:12px; }
    h1{ margin:0; font-size:clamp(26px,3vw,34px); letter-spacing:-0.02em; }
    .tagline{ color:var(--muted); margin:4px 0 0; font-size:15px; }

    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0));
      border:1px solid var(--border);
      border-radius:16px;
      padding:18px;
      box-shadow:0 30px 60px rgba(0,0,0,0.35);
    }

    button{
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      color:#3b0f1f;
      border:none;
      border-radius:10px;
      padding:10px 16px;
      font-weight:700;
      cursor:pointer;
      transition: transform .15s ease, filter .15s ease;
    }
    button:hover{ transform: translateY(-1px); filter: brightness(1.02); }
    button[disabled]{ opacity:.45; cursor:not-allowed; transform:none; filter:none; }

    .ghost-btn{
      background: rgba(255,255,255,0.05);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer;
      transition: all .15s ease;
    }
    .ghost-btn:hover{
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(255,209,102,0.12);
      transform: translateY(-1px);
    }
    .ghost-btn[disabled]{ opacity:.35; cursor:not-allowed; transform:none; }
    .danger{
      border-color:#ef4444;
      color:#ef4444;
    }
    .danger:hover{
      border-color:#ef4444;
      color:#ef4444;
      background: rgba(239,68,68,0.10);
    }

    .score-card{ display:grid; gap:14px; }
    .score-header{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .player-form{ display:flex; gap:8px; flex-wrap:wrap; }
    input, select{
      background: rgba(255,255,255,0.04);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
      color: var(--text);
      min-width: 150px;
    }
    select{ background: var(--card); }

    .table-wrap{ overflow-x:auto; }
    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0 8px;
      min-width: 560px;
    }
    th,td{ padding:10px 8px; text-align:left; }
    thead{ color:var(--muted); font-weight:600; letter-spacing:.01em; }
    tbody tr{
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow:hidden;
    }
    tbody tr td:first-child{ border-top-left-radius:12px; border-bottom-left-radius:12px; }
    tbody tr td:last-child{ border-top-right-radius:12px; border-bottom-right-radius:12px; }
    tbody tr.active-player{
      outline:2px solid rgba(255,209,102,0.9);
      outline-offset:-2px;
      background: rgba(255,209,102,0.08);
    }

    .action-group{ display:flex; gap:6px; align-items:center; flex-wrap:wrap; }
    .action-group input{
      width: 92px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 10px;
      color: var(--text);
      min-width: unset;
    }

    .chip{
      display:inline-flex;
      align-items:center;
      gap:6px;
      background: rgba(255,209,102,0.14);
      border: 1px solid var(--accent);
      color: var(--text);
      border-radius: 999px;
      padding: 6px 10px;
      font-weight: 700;
      letter-spacing: .01em;
    }

    .throw-card{ display:grid; gap:14px; }
    .throw-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .checkout-box{
      background: rgba(255,255,255,0.04);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      display:grid;
      gap:6px;
      font-size:14px;
    }
    .throw-grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(76px, 1fr));
      gap:10px;
    }
    .num-btn{
      background: rgba(255,255,255,0.06);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px 0;
      color: var(--text);
      font-weight: 700;
      letter-spacing: .02em;
      cursor:pointer;
      transition: all .15s ease;
    }
    .num-btn:hover{ border-color: var(--accent); transform: translateY(-1px); }

    .multis{ display:flex; gap:8px; flex-wrap:wrap; }
    .chip-btn{
      background: rgba(255,255,255,0.05);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 999px;
      padding: 8px 12px;
      cursor: pointer;
      font-weight: 700;
      transition: all .15s ease;
    }
    .chip-btn:hover{ border-color: var(--accent); transform: translateY(-1px); }
    .chip-btn.active{
      border-color: var(--accent);
      background: rgba(255,209,102,0.16);
    }

    .muted{ color:var(--muted); }
    .current-selection{ color:var(--muted); font-size:14px; }
    .turn-info{ font-size:14px; color:var(--muted); }

    .throw-log{ display:grid; gap:8px; }
    .throw-entry{
      display:flex;
      justify-content:space-between;
      align-items:center;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
      gap:12px;
    }
    .throw-entry .right{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .throw-sep{ border:0; border-top:1px solid var(--border); margin:6px 0; }

    .stats-note{ color:var(--muted); font-size:13px; margin-bottom:8px; }

    /* Celebration */
    .win-overlay{
      position:fixed; inset:0;
      display:grid; place-items:center;
      pointer-events:none;
      z-index:999;
      animation: fade-out 3s ease forwards;
    }
    .win-banner{
      background: rgba(0,0,0,0.35);
      padding: 16px 22px;
      border-radius: 14px;
      border: 1px solid var(--accent);
      color: var(--text);
      font-weight: 800;
      letter-spacing: .03em;
      backdrop-filter: blur(6px);
      box-shadow: 0 12px 40px rgba(0,0,0,0.35);
    }
    .confetti-piece{
      position:fixed;
      top:-10vh;
      width:8px; height:14px;
      background: var(--accent);
      opacity:.85;
      border-radius:2px;
      pointer-events:none;
      z-index:998;
      animation: confetti-fall linear forwards;
    }
    @keyframes confetti-fall{
      0%{ transform: translateY(0) rotate(0deg); }
      100%{ transform: translateY(110vh) rotate(360deg); }
    }
    @keyframes fade-out{
      0%{ opacity:1; }
      100%{ opacity:0; }
    }

    .mode-actions{ display:flex; gap:8px; flex-wrap:wrap; margin-top:6px; align-items:center; }

    @media (max-width:700px){
      body{ padding:12px; }
      .page{ gap:14px; }
      table{ min-width:100%; }
      .score-header{ flex-direction: column; align-items: stretch; }
      .mode-actions{ width:100%; justify-content:flex-start; }
      .player-form{ width:100%; }
      .player-form > *{ flex:1 1 140px; min-width:140px; }
      .throw-grid{ grid-template-columns: repeat(auto-fit, minmax(64px, 1fr)); gap:8px; }
      .multis{ width:100%; }
      .multis .chip-btn, .multis .ghost-btn{ flex:1 1 100px; min-width:100px; }
      button, .ghost-btn{ width:100%; }
      .checkout-box{ grid-template-columns:1fr; }
    }
  </style>
</head>

<body>
  <main class="page">
    <header>
      <div>
        <h1>Doppel-Dart</h1>
        <p class="tagline">Schnelle Erfassung von Würfen & Punkten</p>
      </div>
    </header>

    <section class="panel score-card">
      <div class="score-header">
        <div>
          <h3 style="margin:0;">Spieler & Spiel</h3>
          <p class="tagline" style="margin-top:4px;">Bis zu 10 Spieler. Modus wählen, Spieler hinzufügen — auch während das Spiel läuft.</p>
          <p class="muted" id="modeInfo" style="margin:6px 0 0;">Modus: 501 (Double-Out)</p>
          <div class="mode-actions">
            <button type="button" class="ghost-btn" id="startGameBtn">Spiel starten</button>
            <button type="button" class="ghost-btn" id="nextRoundBtn">Neue Runde</button>
            <button type="button" class="ghost-btn danger" id="resetAllBtn">Alles zurücksetzen</button>
            <button type="button" class="ghost-btn" id="clearLocalBtn">Lokale Statistik löschen</button>
          </div>
        </div>

        <form id="playerForm" class="player-form">
          <select id="gameMode" name="mode" aria-label="Spielmodus">
            <option value="501" selected>501 (Double-Out)</option>
            <option value="301">301 (Double-Out)</option>
            <option value="atc">Around the Clock</option>
            <option value="shanghai">Shanghai</option>
          </select>
          <input id="playerName" name="name" maxlength="18" placeholder="Name (optional)" />
          <input id="startScore" name="score" type="number" min="0" max="2000" value="501" />
          <button id="addPlayerBtn" type="submit">Spieler hinzufügen</button>
        </form>
      </div>

      <div class="table-wrap">
        <table aria-label="Spieler Tabelle">
          <thead>
            <tr>
              <th>Name</th>
              <th>Sets</th>
              <th>Legs</th>
              <th>Status</th>
              <th>Ø</th>
              <th>Reset/Entfernen</th>
            </tr>
          </thead>
          <tbody id="playerBody">
            <tr class="empty">
              <td colspan="6" style="text-align:center; color:var(--muted);">Noch keine Spieler hinzugefügt.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>

    <section class="panel throw-card">
      <div class="throw-header">
        <div>
          <h3 style="margin:0;">Würfe (1–20 + Bull 25 + 0/Miss)</h3>
          <p class="tagline" style="margin-top:4px;">Multiplikator wählen → Zahl klicken. (Bull: nur Single/Double)</p>
        </div>
        <button id="clearThrows" class="ghost-btn">Runde leeren</button>
      </div>

      <div class="checkout-box" id="checkoutBox"></div>

      <div class="multis" id="multiButtons" aria-label="Multiplikator">
        <button type="button" class="chip-btn active" data-mult="1">Single</button>
        <button type="button" class="chip-btn" data-mult="2">Double</button>
        <button type="button" class="chip-btn" data-mult="3">Triple</button>
        <button type="button" class="ghost-btn" id="missBtn">0 (Fehlwurf)</button>
      </div>

      <div class="current-selection" id="currentSelection">Auswahl: Single</div>
      <div class="turn-info" id="turnInfo">Aktiver Spieler: –</div>

      <div class="throw-grid" id="throwNumbers"></div>

      <div class="throw-log" id="throwLog">
        <div class="muted">Noch keine Würfe erfasst.</div>
      </div>
    </section>

    <section class="panel">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
        <div>
          <h3 style="margin:0;">Statistik je Spieler</h3>
          <div class="stats-note" id="statsNote">Darts, Singles/Doubles/Triples, Punkte, Ø Punkte/Dart.</div>
        </div>
      </div>
      <div class="table-wrap">
        <table aria-label="Statistik">
          <thead id="statsHead"></thead>
          <tbody id="statsBody">
            <tr class="empty">
              <td style="text-align:center; color:var(--muted);">Noch keine Daten.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
  </main>

  <!-- Socket optional (nur wenn du Backend wirklich nutzt) -->
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

  <script>
    // ============================================================
    // KONFIG
    // ============================================================
    const API_BASE = "http://localhost:4000";
    let useBackend = false; // <- TRUE nur, wenn du wirklich Backend/Socket hast.

    const LOCAL_KEY = "dart-local-state-v2";
    const MAX_PLAYERS = 10;

    const MODES = {
      "501": { label: "501 (Double-Out)", start: 501, type: "x01" },
      "301": { label: "301 (Double-Out)", start: 301, type: "x01" },
      "atc": { label: "Around the Clock", start: 0, type: "atc" },
      "shanghai": { label: "Shanghai", start: 0, type: "shanghai" }
    };

    const throwNumbersList = [...Array(20).keys()].map(n => n + 1).concat([25]);

    // ============================================================
    // DOM
    // ============================================================
    const playerForm = document.getElementById("playerForm");
    const playerNameInput = document.getElementById("playerName");
    const startScoreInput = document.getElementById("startScore");
    const playerBody = document.getElementById("playerBody");
    const gameModeSelect = document.getElementById("gameMode");
    const modeInfo = document.getElementById("modeInfo");

    const throwNumbers = document.getElementById("throwNumbers");
    const multiButtons = document.getElementById("multiButtons");
    const currentSelection = document.getElementById("currentSelection");
    const missBtn = document.getElementById("missBtn");
    const throwLog = document.getElementById("throwLog");
    const clearThrowsBtn = document.getElementById("clearThrows");
    const startGameBtn = document.getElementById("startGameBtn");
    const nextRoundBtn = document.getElementById("nextRoundBtn");
    const resetAllBtn = document.getElementById("resetAllBtn");
    const clearLocalBtn = document.getElementById("clearLocalBtn");
    const turnInfo = document.getElementById("turnInfo");
    const checkoutBox = document.getElementById("checkoutBox");

    const statsHead = document.getElementById("statsHead");
    const statsBody = document.getElementById("statsBody");
    const statsNote = document.getElementById("statsNote");

    // ============================================================
    // STATE
    // ============================================================
    const state = {
      mode: gameModeSelect.value,

      // neu
      matchStarted: false,  // wurde jemals gestartet?
      legEnded: false,      // gerade zwischen zwei Legs?

      running: false,

      players: [], // {id,name,score,legs,sets}
      throws: [],  // {id, playerId, num, mult, score, turn, dartInTurn, bust?, finishAttempt?, hitFlag?}
      statsTotals: {}, // playerId -> {darts,singles,doubles,triples,points}

      currentPlayerIndex: 0,
      dartsInTurn: 0,
      globalTurnCounter: 1,
      turnSnapshot: null, // snapshot per turn (bust/Shanghai S/D/T)

      // mode-specific
      atcTargetIndex: {},  // playerId -> 0..20 (20 => Bull)
      shanghaiRound: 1,     // 1..20
      shanghaiPoints: {},   // playerId -> points
    };

    // ============================================================
    // UTIL
    // ============================================================
    const createId = () => {
      return (typeof crypto !== "undefined" && crypto.randomUUID)
        ? crypto.randomUUID()
        : "id-" + Math.random().toString(16).slice(2);
    };

    const clampScore = (value, fallback) => {
      const n = Number(value);
      return Number.isFinite(n) ? Math.max(0, Math.min(2000, n)) : fallback;
    };

    function labelForMultiplier(m){
      if (m === 1) return "Single";
      if (m === 2) return "Double";
      return "Triple";
    }

    function isValidTriple(num){ return num >= 1 && num <= 20; }

    function computeScore(num, mult){
      if (num === 25 && mult === 2) return 50;
      if (num === 25 && mult === 1) return 25;
      return num * mult;
    }

    function isFinishingDouble(num, mult){
      if (num === 25 && mult === 2) return true; // Double Bull
      return mult === 2;
    }

    function getMode(){ return MODES[state.mode]; }

    function getATCTargetForPlayer(playerId){
      const idx = (state.atcTargetIndex[playerId] != null) ? state.atcTargetIndex[playerId] : 0;
      if (idx <= 19) return idx + 1; // 1..20
      return 25; // Bull
    }

    function suggestCheckout(score) {
      const chart = {
        170:"T20 T20 Bull", 167:"T20 T19 Bull", 164:"T20 T18 Bull", 161:"T20 T17 Bull",
        160:"T20 T20 D20", 158:"T20 T20 D19", 157:"T20 T19 D20", 156:"T20 T20 D18",
        155:"T20 T19 D19", 154:"T20 T18 D20", 153:"T20 T19 D18", 152:"T20 T20 D16",
        151:"T20 T17 D20", 150:"T20 T18 D18", 149:"T20 T19 D16", 148:"T20 T16 D20",
        147:"T20 T17 D18", 146:"T20 T18 D16", 145:"T20 T15 D20", 144:"T20 T20 D12",
        143:"T20 T17 D16", 142:"T20 T14 D20", 141:"T20 T19 D12", 140:"T20 T20 D10",
        139:"T20 T13 D20", 138:"T20 T18 D12", 137:"T20 T19 D10", 136:"T20 T20 D8",
        135:"T20 T17 D12", 134:"T20 T14 D16", 133:"T20 T19 D8", 132:"Bull Bull D16",
        131:"T20 T13 D16", 130:"T20 T20 D5", 129:"T19 T16 D12", 128:"T18 T14 D16",
        127:"T20 T17 D8", 126:"T19 T19 D6", 125:"T18 T13 D16", 124:"T20 T16 D8",
        123:"T19 T16 D9", 122:"T18 T20 D4", 121:"T20 T11 D14",
        120:"T20 S20 D20", 118:"T20 S18 D20", 117:"T20 S17 D20", 116:"T20 S16 D20",
        115:"T20 S15 D20", 114:"T20 S14 D20", 112:"T20 S12 D20", 110:"T20 S10 D20",
        108:"T20 S16 D16", 107:"T19 S10 D20", 106:"T20 S6 D20", 105:"T20 S13 D16",
        104:"T18 S18 D16", 103:"T20 S3 D20", 102:"T20 S10 D16", 101:"T17 S18 D16",
        100:"T20 D20",
         99:"T19 S10 D16",  98:"T20 D19",  97:"T19 D20",  96:"T20 D18",
         95:"T19 D19",  94:"T18 D20",  93:"T19 D18",  92:"T20 D16",
         91:"T17 D20",  90:"T18 D18",  89:"T19 D16",  88:"T20 D14",
         87:"T17 D18",  86:"T18 D16",  85:"T15 D20",  84:"T20 D12",
         83:"T17 D16",  82:"Bull D16", 81:"T19 D12", 80:"T20 D10",
         78:"T18 D12",  76:"T20 D8",  75:"T17 D12",  74:"T14 D16",
         72:"T16 D12",  70:"T18 D8",  68:"T16 D10",  66:"T10 D18",
         65:"T19 D4",   64:"T16 D8",   62:"T10 D16",  60:"S20 D20",
         58:"S18 D20",  56:"S16 D20",  54:"S14 D20",  52:"S20 D16",
         50:"S18 D16",  48:"S16 D16",  46:"S14 D16",  44:"S12 D16",
         42:"S10 D16",  40:"D20", 38:"D19", 36:"D18", 34:"D17", 32:"D16",
         30:"D15", 28:"D14", 26:"D13", 24:"D12", 22:"D11", 20:"D10",
         18:"D9", 16:"D8", 14:"D7", 12:"D6", 10:"D5", 8:"D4", 6:"D3", 4:"D2", 2:"D1"
      };
      if (score > 170) return "Unter 170 kommen, dann Checkout spielen.";
      return chart[score] || "Rest stellen (Double-Out beachten).";
    }

    // ============================================================
    // LOCAL PERSISTENCE (nur Offline)
    // ============================================================
    function saveLocalState(){
      if (useBackend) return;
      try {
        const payload = {
          v: 2,
          mode: state.mode,
          matchStarted: state.matchStarted,
          legEnded: state.legEnded,
          running: state.running,
          players: state.players,
          throws: state.throws,
          statsTotals: state.statsTotals,
          currentPlayerIndex: state.currentPlayerIndex,
          dartsInTurn: state.dartsInTurn,
          globalTurnCounter: state.globalTurnCounter,
          turnSnapshot: state.turnSnapshot,
          atcTargetIndex: state.atcTargetIndex,
          shanghaiRound: state.shanghaiRound,
          shanghaiPoints: state.shanghaiPoints
        };
        localStorage.setItem(LOCAL_KEY, JSON.stringify(payload));
      } catch (e) {
        console.warn("Local save failed:", e);
      }
    }

    function loadLocalState(){
      if (useBackend) return;
      try {
        const raw = localStorage.getItem(LOCAL_KEY);
        if (!raw) return;
        const data = JSON.parse(raw);
        if (!data || data.v !== 2) return;

        state.mode = data.mode || state.mode;
        state.matchStarted = !!data.matchStarted;
        state.legEnded = !!data.legEnded;
        state.running = !!data.running;
        state.players = Array.isArray(data.players) ? data.players : [];
        state.throws = Array.isArray(data.throws) ? data.throws : [];
        state.statsTotals = data.statsTotals || {};
        state.currentPlayerIndex = data.currentPlayerIndex || 0;
        state.dartsInTurn = data.dartsInTurn || 0;
        state.globalTurnCounter = data.globalTurnCounter || 1;
        state.turnSnapshot = data.turnSnapshot || null;
        state.atcTargetIndex = data.atcTargetIndex || {};
        state.shanghaiRound = data.shanghaiRound || 1;
        state.shanghaiPoints = data.shanghaiPoints || {};

        gameModeSelect.value = state.mode;
        renderAll();
      } catch (e) {
        console.warn("Local load failed:", e);
      }
    }

    function clearLocalState(){
      if (useBackend) return;
      localStorage.removeItem(LOCAL_KEY);
      hardResetButKeepPlayers(false);
    }

    // ============================================================
    // CELEBRATION
    // ============================================================
    function triggerWinCelebration(text){
      const overlay = document.createElement("div");
      overlay.className = "win-overlay";
      const banner = document.createElement("div");
      banner.className = "win-banner";
      banner.textContent = text;
      overlay.appendChild(banner);
      document.body.appendChild(overlay);

      const colors = ["#ffd166","#ff9f1c","#f7eef2","#e0c9d4"];
      for (let i=0;i<80;i++){
        const piece = document.createElement("div");
        piece.className = "confetti-piece";
        piece.style.left = `${Math.random()*100}vw`;
        piece.style.background = colors[i % colors.length];
        const duration = 2 + Math.random()*1.5;
        const delay = Math.random()*0.2;
        piece.style.animationDuration = `${duration}s`;
        piece.style.animationDelay = `${delay}s`;
        document.body.appendChild(piece);
        setTimeout(() => piece.remove(), (duration + delay)*1000 + 200);
      }
      setTimeout(() => overlay.remove(), 3000);
    }

    // ============================================================
    // MULTIPLIER UI
    // ============================================================
    let selectedMultiplier = 1;

    function renderMultiplierUI(){
      multiButtons.querySelectorAll(".chip-btn").forEach(btn => {
        const mult = Number(btn.dataset.mult);
        btn.classList.toggle("active", mult === selectedMultiplier);
      });
      currentSelection.textContent = `Auswahl: ${labelForMultiplier(selectedMultiplier)}`;
    }

    multiButtons.addEventListener("click", (e) => {
      const btn = e.target.closest(".chip-btn");
      if (!btn) return;
      selectedMultiplier = Number(btn.dataset.mult) || 1;
      renderMultiplierUI();
    });

    // ============================================================
    // PLAYER + INIT FOR MODE
    // ============================================================
    function ensureStats(playerId){
      if (!state.statsTotals[playerId]){
        state.statsTotals[playerId] = { darts:0, singles:0, doubles:0, triples:0, points:0 };
      }
    }

    function initPlayerForCurrentMode(player){
      const m = getMode();
      ensureStats(player.id);

      if (m.type === "x01"){
        player.score = m.start;
      } else if (m.type === "atc"){
        state.atcTargetIndex[player.id] = 0;
      } else {
        state.shanghaiPoints[player.id] = 0;
      }
    }

    function createPlayer(name){
      const m = getMode();

      // Wenn Spiel läuft: x01 Startscore IMMER m.start (dein Wunsch)
      // Wenn Spiel NICHT läuft: du darfst im UI startScoreInput nutzen
      const start = (m.type === "x01")
        ? (state.running ? m.start : clampScore(startScoreInput.value, m.start))
        : 0;

      return {
        id: createId(),
        name,
        score: start,
        legs: 0,
        sets: 0
      };
    }

    function removePlayer(playerId){
      const idx = state.players.findIndex(p => p.id === playerId);
      if (idx === -1) return;

      state.players.splice(idx, 1);
      delete state.statsTotals[playerId];
      delete state.atcTargetIndex[playerId];
      delete state.shanghaiPoints[playerId];

      state.throws = state.throws.filter(t => t.playerId !== playerId);

      if (state.currentPlayerIndex >= state.players.length) state.currentPlayerIndex = 0;
      recomputeFromThrows(); // hält Spiel konsistent
    }

    // Reset einzelner Spieler: nur wenn NICHT running (wird auch UI-disabled)
    function resetPlayer(playerId){
      const p = state.players.find(x => x.id === playerId);
      if (!p) return;

      initPlayerForCurrentMode(p);
      state.throws = state.throws.filter(t => t.playerId !== playerId);
      state.statsTotals[playerId] = { darts:0, singles:0, doubles:0, triples:0, points:0 };

      // Turn state sauber setzen (falls Spieler aktuell war)
      state.currentPlayerIndex = 0;
      state.dartsInTurn = 0;
      state.globalTurnCounter = 1;
      state.turnSnapshot = snapshotTurnForCurrentPlayer();

      recomputeFromThrows();
    }

    // ============================================================
    // TURN / ROUND CONTROL
    // ============================================================
    function snapshotTurnForCurrentPlayer(){
      const p = state.players[state.currentPlayerIndex];
      const m = getMode();
      if (!p) return null;

      if (m.type === "x01"){
        return { score: p.score };
      }
      if (m.type === "atc"){
        return { targetIndex: state.atcTargetIndex[p.id] ?? 0 };
      }
      // Shanghai: track s/d/t hits within this turn for current round
      return { s:false, d:false, t:false };
    }

    function advancePlayer(){
      if (!state.players.length) return;
      state.currentPlayerIndex = (state.currentPlayerIndex + 1) % state.players.length;
      state.dartsInTurn = 0;
      state.globalTurnCounter += 1;
      state.turnSnapshot = snapshotTurnForCurrentPlayer();
    }

    function endTurn(){
      const m = getMode();
      advancePlayer();

      if (m.type === "shanghai"){
        if (state.currentPlayerIndex === 0){
          state.shanghaiRound += 1;
          if (state.shanghaiRound > 20){
            // winner by points
            const winner = state.players
              .map(p => ({ p, pts: state.shanghaiPoints[p.id] ?? 0 }))
              .sort((a,b) => b.pts - a.pts)[0];
            triggerWinCelebration(`Shanghai Ende! Gewinner: ${winner.p.name} (${winner.pts} Punkte)`);
            startLegFresh(); // neues Leg
            return;
          }
        }
        state.turnSnapshot = snapshotTurnForCurrentPlayer();
      }
    }

    function bustCurrentTurn(){
      const p = state.players[state.currentPlayerIndex];
      const m = getMode();
      const snap = state.turnSnapshot;
      if (!p || !snap) return;

      if (m.type === "x01"){
        p.score = snap.score;
      }
      endTurn();
    }

    function startLegFresh(){
      const m = getMode();

      // Leg läuft jetzt
      state.matchStarted = true;
      state.running = true;
      state.legEnded = false;

      // Leg-Log leeren (Stats bleiben über Match erhalten)
      state.throws.length = 0;

      // StatsTotals NICHT löschen (cumulative). Nur sicherstellen, dass jeder Spieler einen Eintrag hat.
      state.players.forEach(p => ensureStats(p.id));

      // mode-specific reset fürs neue Leg
      if (m.type === "x01"){
        state.players.forEach(p => { p.score = m.start; });
      } else if (m.type === "atc"){
        // ATC pro Leg neu
        state.atcTargetIndex = {};
        state.players.forEach(p => state.atcTargetIndex[p.id] = 0);
      } else {
        // Shanghai pro Leg neu
        state.shanghaiRound = 1;
        state.shanghaiPoints = {};
        state.players.forEach(p => state.shanghaiPoints[p.id] = 0);
      }

      state.currentPlayerIndex = 0;
      state.dartsInTurn = 0;
      state.globalTurnCounter = 1;
      state.turnSnapshot = snapshotTurnForCurrentPlayer();

      renderAll();
      saveLocalState();
    }

    function startGame(){
      if (useBackend){
        alert("Backend-Modus: Start/Sync bitte über dein Backend lösen (hier Offline-Start). Setze useBackend=false.");
        return;
      }
      if (!state.players.length){
        alert("Bitte zuerst Spieler anlegen.");
        return;
      }

      state.mode = gameModeSelect.value;

      // Wenn Match schon gestartet war und nur pausiert ist (legEnded), starten wir das nächste Leg:
      startLegFresh();
    }

    function nextRound(){
      if (useBackend){
        alert("Backend-Modus: Neue Runde bitte serverseitig starten.");
        return;
      }
      if (!state.players.length) return;

      // Starter rotieren: erster Spieler ans Ende
      const first = state.players.shift();
      state.players.push(first);

      startLegFresh();
    }

    function hardResetButKeepPlayers(keepPlayers = true){
      // alles resetten, optional Spieler behalten
      state.matchStarted = false;
      state.legEnded = false;
      state.running = false;
      state.throws.length = 0;
      state.statsTotals = {};

      state.atcTargetIndex = {};
      state.shanghaiPoints = {};
      state.shanghaiRound = 1;

      state.currentPlayerIndex = 0;
      state.dartsInTurn = 0;
      state.globalTurnCounter = 1;
      state.turnSnapshot = null;

      if (!keepPlayers){
        state.players = [];
      } else {
        // Sets/Legs zurücksetzen und Scores passend zum Modus
        const m = getMode();
        state.players.forEach(p => {
          p.legs = 0; p.sets = 0;
          ensureStats(p.id);
          if (m.type === "x01") p.score = m.start;
          if (m.type === "atc") state.atcTargetIndex[p.id] = 0;
          if (m.type === "shanghai") state.shanghaiPoints[p.id] = 0;
        });
      }

      renderAll();
      saveLocalState();
    }

    // ============================================================
    // THROW / STATS
    // ============================================================
    function accumulateStats(playerId, mult, score){
      ensureStats(playerId);
      const s = state.statsTotals[playerId];
      s.darts += 1;
      if (mult === 1) s.singles += 1;
      else if (mult === 2) s.doubles += 1;
      else if (mult === 3) s.triples += 1;
      s.points += score;
    }

    // Leg-Ende pausieren
    function endLeg(winnerName){
      state.running = false;
      state.legEnded = true;

      triggerWinCelebration(`Leg gewonnen: ${winnerName}!`);

      renderAll();
      saveLocalState();
    }

    function recordThrow(playerId, num, mult){
      // normalize constraints
      if (num === 25 && mult === 3) mult = 2;
      if (mult === 3 && !isValidTriple(num)) mult = 2;

      const score = (num === 0) ? 0 : computeScore(num, mult);

      const entry = {
        id: createId(),
        playerId,
        num,
        mult,
        score,
        turn: state.globalTurnCounter,
        dartInTurn: state.dartsInTurn + 1
      };
      state.throws.push(entry);
      accumulateStats(playerId, mult, score);
      return entry;
    }

    async function addThrow(num){
      if (!state.players.length){
        alert("Bitte zuerst Spieler anlegen.");
        return;
      }
      if (!state.running){
        if (state.legEnded){
          alert("Leg ist beendet. Drücke „Neue Runde“, um das nächste Leg zu starten.");
        } else {
          alert("Bitte erst „Spiel starten“ drücken.");
        }
        return;
      }

      if (useBackend){
        alert("Backend-Modus ist hier nicht implementiert (useBackend=false empfohlen).");
        return;
      }

      const p = state.players[state.currentPlayerIndex];
      const m = getMode();

      // Miss
      if (num === 0){
        recordThrow(p.id, 0, 1);
        state.dartsInTurn += 1;
        if (state.dartsInTurn >= 3) endTurn();
        renderAll(); saveLocalState();
        return;
      }

      // multiplier selection with constraints
      let mult = selectedMultiplier || 1;
      if (num === 25 && mult === 3) mult = 2;
      if (mult === 3 && !isValidTriple(num)) mult = 2;

      const entry = recordThrow(p.id, num, mult);

      // --- apply mode rules ---
      if (m.type === "x01"){
        // snapshot if missing
        if (!state.turnSnapshot) state.turnSnapshot = snapshotTurnForCurrentPlayer();

        const newScore = p.score - entry.score;

        if (newScore < 0 || newScore === 1){
          entry.bust = true;
          bustCurrentTurn();
          renderAll(); saveLocalState();
          selectedMultiplier = 1; renderMultiplierUI();
          return;
        }

        if (newScore === 0){
          if (!isFinishingDouble(num, mult)){
            entry.bust = true;
            entry.finishAttempt = true;
            bustCurrentTurn();
            renderAll(); saveLocalState();
            selectedMultiplier = 1; renderMultiplierUI();
            return;
          }

          // WIN
          p.legs = (p.legs || 0) + 1;
          if (p.legs >= 3){
            p.sets = (p.sets || 0) + 1;
            state.players.forEach(pl => pl.legs = 0);
          }
          p.score = 0;

          // Winner soll nächstes Leg anfangen: an den Anfang schieben
          state.players = [p, ...state.players.filter(x => x.id !== p.id)];

          // Leg pausieren statt automatisch neu starten:
          endLeg(p.name);

          selectedMultiplier = 1;
          renderMultiplierUI();
          return;
        }

        p.score = newScore;

        state.dartsInTurn += 1;
        if (state.dartsInTurn >= 3) endTurn();

        renderAll(); saveLocalState();
        selectedMultiplier = 1; renderMultiplierUI();
        return;
      }

      if (m.type === "atc"){
        const target = getATCTargetForPlayer(p.id);
        const hit = (target === 25) ? (num === 25) : (num === target);

        if (hit){
          entry.hitFlag = true;
          state.atcTargetIndex[p.id] = (state.atcTargetIndex[p.id] ?? 0) + 1;

          if ((state.atcTargetIndex[p.id] ?? 0) >= 21){
            p.legs = (p.legs || 0) + 1;
            triggerWinCelebration(`ATC: ${p.name} hat gewonnen!`);
            startLegFresh();
            selectedMultiplier = 1; renderMultiplierUI();
            return;
          }
        }

        state.dartsInTurn += 1;
        if (state.dartsInTurn >= 3) endTurn();

        renderAll(); saveLocalState();
        selectedMultiplier = 1; renderMultiplierUI();
        return;
      }

      // Shanghai
      if (m.type === "shanghai"){
        const round = state.shanghaiRound;

        // snapshot holds s/d/t flags for THIS player turn
        if (!state.turnSnapshot || typeof state.turnSnapshot.s !== "boolean"){
          state.turnSnapshot = snapshotTurnForCurrentPlayer();
        }

        if (num === round){
          entry.hitFlag = true;
          state.shanghaiPoints[p.id] = (state.shanghaiPoints[p.id] ?? 0) + entry.score;

          if (mult === 1) state.turnSnapshot.s = true;
          if (mult === 2) state.turnSnapshot.d = true;
          if (mult === 3) state.turnSnapshot.t = true;

          if (state.turnSnapshot.s && state.turnSnapshot.d && state.turnSnapshot.t){
            p.legs = (p.legs || 0) + 1;
            if (p.legs >= 3){
              p.sets = (p.sets || 0) + 1;
              state.players.forEach(pl => pl.legs = 0);
            }
            triggerWinCelebration(`Shanghai! ${p.name} gewinnt in Runde ${round}!`);
            startLegFresh();
            selectedMultiplier = 1; renderMultiplierUI();
            return;
          }
        }

        state.dartsInTurn += 1;
        if (state.dartsInTurn >= 3) endTurn();

        renderAll(); saveLocalState();
        selectedMultiplier = 1; renderMultiplierUI();
        return;
      }
    }

    // ============================================================
    // EDIT / DELETE THROWS
    // ============================================================
    function editThrow(index){
      const t = state.throws[index];
      if (!t) return;

      const newNumStr = prompt("Neue Zahl (0–20 oder 25 für Bull):", String(t.num));
      if (newNumStr === null) return;
      const newNum = Number(newNumStr);
      const allowedNums = [0, 25, ...Array.from({length:20},(_,i)=>i+1)];
      if (!Number.isFinite(newNum) || !allowedNums.includes(newNum)){
        alert("Bitte 0–20 oder 25 eingeben.");
        return;
      }

      const newMultStr = prompt("Neuer Multiplikator (1=Single, 2=Double, 3=Triple):", String(t.mult));
      if (newMultStr === null) return;
      const newMult = Number(newMultStr);
      if (![1,2,3].includes(newMult)){
        alert("Multiplikator 1/2/3 wählen.");
        return;
      }

      if (newNum === 25 && newMult === 3){
        alert("Triple Bull gibt es nicht. Nutze Single oder Double.");
        return;
      }
      if (newMult === 3 && !isValidTriple(newNum)){
        alert("Triple nur bei 1–20 erlaubt.");
        return;
      }

      t.num = newNum;
      t.mult = newMult;

      recomputeFromThrows();
      renderAll(); saveLocalState();
    }

    function recomputeFromThrows(){
      // Re-simulate everything from the current throw list (offline)
      if (!state.players.length) return;

      const m = getMode();

      // Keep players and their legs/sets, but recompute scores/points/progress from scratch within current leg
      // (Throws are only for the current leg anyway in this UI)
      const legsSets = state.players.map(p => ({ id:p.id, legs:p.legs||0, sets:p.sets||0, name:p.name }));
      const preservedPlayers = [...state.players];

      // Reset core
      state.statsTotals = {};
      preservedPlayers.forEach(p => ensureStats(p.id));

      state.currentPlayerIndex = 0;
      state.dartsInTurn = 0;
      state.globalTurnCounter = 1;
      state.turnSnapshot = null;
      state.running = true;

      // Mode-specific reset
      if (m.type === "x01"){
        preservedPlayers.forEach(p => p.score = m.start);
      }
      if (m.type === "atc"){
        state.atcTargetIndex = {};
        preservedPlayers.forEach(p => state.atcTargetIndex[p.id] = 0);
      }
      if (m.type === "shanghai"){
        state.shanghaiRound = 1;
        state.shanghaiPoints = {};
        preservedPlayers.forEach(p => state.shanghaiPoints[p.id] = 0);
      }

      // Restore legs/sets
      preservedPlayers.forEach(p => {
        const ls = legsSets.find(x => x.id === p.id);
        if (ls){ p.legs = ls.legs; p.sets = ls.sets; }
      });

      state.players = preservedPlayers;
      state.turnSnapshot = snapshotTurnForCurrentPlayer();

      // Rebuild throws by simulating their order
      const originalThrows = [...state.throws];
      state.throws = [];

      for (let i=0; i<originalThrows.length; i++){
        const t = originalThrows[i];
        const playerIndex = state.players.findIndex(p => p.id === t.playerId);
        if (playerIndex === -1) continue;

        // Rotate until current player matches t.playerId
        while (state.players[state.currentPlayerIndex]?.id !== t.playerId){
          endTurn();
        }

        // Record same throw (re-normalize)
        const entry = recordThrow(t.playerId, t.num, t.mult);

        // Copy intent (then we re-calc flags below)
        // Apply mode logic
        const p = state.players[state.currentPlayerIndex];

        if (m.type === "x01"){
          if (!state.turnSnapshot) state.turnSnapshot = snapshotTurnForCurrentPlayer();

          if (entry.num === 0){
            state.dartsInTurn += 1;
            if (state.dartsInTurn >= 3) endTurn();
            continue;
          }

          const newScore = p.score - entry.score;

          if (newScore < 0 || newScore === 1){
            entry.bust = true;
            bustCurrentTurn();
            continue;
          }

          if (newScore === 0){
            if (!isFinishingDouble(entry.num, entry.mult)){
              entry.bust = true;
              entry.finishAttempt = true;
              bustCurrentTurn();
              continue;
            }
            // Win: we stop here (everything after is invalid for that leg)
            p.legs = (p.legs || 0) + 1;
            if (p.legs >= 3){
              p.sets = (p.sets || 0) + 1;
              state.players.forEach(pl => pl.legs = 0);
            }
            state.players = [p, ...state.players.filter(x => x.id !== p.id)];
            // After win, leg restarts (clear all throws)
            startLegFresh();
            return;
          }

          p.score = newScore;
          state.dartsInTurn += 1;
          if (state.dartsInTurn >= 3) endTurn();
          continue;
        }

        if (m.type === "atc"){
          if (entry.num === 0){
            state.dartsInTurn += 1;
            if (state.dartsInTurn >= 3) endTurn();
            continue;
          }
          const target = getATCTargetForPlayer(p.id);
          const hit = (target === 25) ? (entry.num === 25) : (entry.num === target);

          if (hit){
            entry.hitFlag = true;
            state.atcTargetIndex[p.id] = (state.atcTargetIndex[p.id] ?? 0) + 1;
            if ((state.atcTargetIndex[p.id] ?? 0) >= 21){
              p.legs = (p.legs || 0) + 1;
              startLegFresh();
              return;
            }
          }

          state.dartsInTurn += 1;
          if (state.dartsInTurn >= 3) endTurn();
          continue;
        }

        // Shanghai
        if (m.type === "shanghai"){
          if (!state.turnSnapshot || typeof state.turnSnapshot.s !== "boolean"){
            state.turnSnapshot = snapshotTurnForCurrentPlayer();
          }

          const round = state.shanghaiRound;

          if (entry.num === 0){
            state.dartsInTurn += 1;
            if (state.dartsInTurn >= 3) endTurn();
            continue;
          }

          if (entry.num === round){
            entry.hitFlag = true;
            state.shanghaiPoints[p.id] = (state.shanghaiPoints[p.id] ?? 0) + entry.score;

            if (entry.mult === 1) state.turnSnapshot.s = true;
            if (entry.mult === 2) state.turnSnapshot.d = true;
            if (entry.mult === 3) state.turnSnapshot.t = true;

            if (state.turnSnapshot.s && state.turnSnapshot.d && state.turnSnapshot.t){
              startLegFresh();
              return;
            }
          }

          state.dartsInTurn += 1;
          if (state.dartsInTurn >= 3) endTurn();
          continue;
        }
      }
    }

    // ============================================================
    // RENDERING
    // ============================================================
    function renderModeInfo(){
      const m = getMode();
      modeInfo.textContent = `Modus: ${m.label}`;

      // UI: Startscore-Feld sinnvoll
      if (m.type === "x01") startScoreInput.value = m.start;
      else startScoreInput.value = 0;

      // Moduswechsel nur wenn nicht running (sonst Chaos)
      gameModeSelect.disabled = state.running;
      startScoreInput.disabled = state.running;
    }

    function renderThrowNumbers(){
      throwNumbers.innerHTML = "";
      throwNumbersList.forEach(num => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "num-btn";
        btn.textContent = (num === 25 ? "25 (Bull)" : String(num));
        btn.addEventListener("click", () => addThrow(num));
        throwNumbers.appendChild(btn);
      });
    }

    function renderTurnInfo(){
      if (!state.players.length){
        turnInfo.textContent = "Aktiver Spieler: –";
        return;
      }
      if (!state.running){
        turnInfo.textContent = "Aktiver Spieler: – (Spiel nicht gestartet)";
        return;
      }

      const p = state.players[state.currentPlayerIndex];
      const dartNo = Math.min(state.dartsInTurn + 1, 3);
      const m = getMode();

      if (m.type === "x01"){
        turnInfo.textContent = `Aktiver Spieler: ${p.name} — Dart ${dartNo}/3 — Rest: ${p.score}`;
      } else if (m.type === "atc"){
        const target = getATCTargetForPlayer(p.id);
        turnInfo.textContent = `Aktiver Spieler: ${p.name} — Dart ${dartNo}/3 — Ziel: ${target === 25 ? "Bull" : target}`;
      } else {
        turnInfo.textContent = `Aktiver Spieler: ${p.name} — Dart ${dartNo}/3 — Runde: ${state.shanghaiRound}`;
      }
    }

    function renderCheckoutBox(){
      const m = getMode();

      if (!state.players.length){
        checkoutBox.innerHTML = `
          <div><strong>Aktiver Spieler:</strong> –</div>
          <div><strong>Info:</strong> –</div>
        `;
        return;
      }

      if (!state.running){
        checkoutBox.innerHTML = `
          <div><strong>Aktiver Spieler:</strong> –</div>
          <div class="muted">Drücke „Spiel starten“.</div>
        `;
        return;
      }

      const p = state.players[state.currentPlayerIndex];

      if (m.type === "x01"){
        const dartsLeft = Math.max(0, 3 - state.dartsInTurn);
        checkoutBox.innerHTML = `
          <div><strong>Aktiver Spieler:</strong> ${p.name}</div>
          <div><strong>Rest:</strong> ${p.score}</div>
          <div><strong>Empfehlung:</strong> ${suggestCheckout(p.score)}</div>
          <div><strong>Darts übrig (Aufnahme):</strong> ${dartsLeft}</div>
        `;
        return;
      }

      if (m.type === "atc"){
        const t = getATCTargetForPlayer(p.id);
        checkoutBox.innerHTML = `
          <div><strong>Aktiver Spieler:</strong> ${p.name}</div>
          <div><strong>Ziel:</strong> ${t === 25 ? "Bull" : t}</div>
          <div class="muted">Treffe die Zahl in Reihenfolge. Bull zählt mit 25 oder 50.</div>
        `;
        return;
      }

      // shanghai
      const pts = state.shanghaiPoints[p.id] ?? 0;
      checkoutBox.innerHTML = `
        <div><strong>Aktiver Spieler:</strong> ${p.name}</div>
        <div><strong>Runde:</strong> ${state.shanghaiRound} / 20</div>
        <div><strong>Punkte:</strong> ${pts}</div>
        <div class="muted">Punkte nur, wenn du die Rundenzahl triffst. Shanghai (S+D+T in einer Aufnahme) = Sofort-Sieg.</div>
      `;
    }

    function renderPlayers(){
      playerBody.innerHTML = "";

      if (!state.players.length){
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="6" style="text-align:center; color:var(--muted);">Noch keine Spieler hinzugefügt.</td>`;
        playerBody.appendChild(tr);
        return;
      }

      const m = getMode();

      state.players.forEach((p, idx) => {
        const tr = document.createElement("tr");
        if (state.running && idx === state.currentPlayerIndex) tr.classList.add("active-player");

        const nameTd = document.createElement("td");
        nameTd.textContent = p.name;

        const setsTd = document.createElement("td");
        setsTd.innerHTML = `<span class="chip">${p.sets || 0}</span>`;

        const legsTd = document.createElement("td");
        legsTd.innerHTML = `<span class="chip">${p.legs || 0}</span>`;

        const statusTd = document.createElement("td");
        if (m.type === "x01"){
          statusTd.innerHTML = `<span class="chip">${p.score}</span>`;
        } else if (m.type === "atc"){
          const t = getATCTargetForPlayer(p.id);
          const done = state.atcTargetIndex[p.id] ?? 0;
          statusTd.innerHTML = `<span class="chip">Ziel: ${t === 25 ? "Bull" : t}</span> <span class="muted">(${done}/21)</span>`;
        } else {
          const pts = state.shanghaiPoints[p.id] ?? 0;
          statusTd.innerHTML = `<span class="chip">${pts} P</span>`;
        }

        const avgTd = document.createElement("td");
        let avg = "–";
        if (m.type === "x01"){
          const darts = state.throws.filter(t => t.playerId === p.id).length;
          const points = state.throws.filter(t => t.playerId === p.id).reduce((sum, t) => sum + t.score, 0);
          avg = darts > 0 ? (points / darts).toFixed(1) : "0.0";
        }
        avgTd.textContent = (m.type === "x01") ? avg : "–";

        const actionsTd = document.createElement("td");
        const wrap = document.createElement("div");
        wrap.className = "action-group";

        const resetBtn = document.createElement("button");
        resetBtn.type = "button";
        resetBtn.className = "ghost-btn";
        resetBtn.textContent = "Reset";
        // WICHTIG: während running NICHT resetten dürfen (dein Wunsch)
        resetBtn.disabled = state.running;
        resetBtn.title = state.running ? "Während eines laufenden Spiels gesperrt." : "";
        resetBtn.addEventListener("click", () => {
          if (state.running) return;
          resetPlayer(p.id);
          renderAll(); saveLocalState();
        });

        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.className = "ghost-btn danger";
        removeBtn.textContent = "Entfernen";
        // WICHTIG: während running NICHT entfernen dürfen
        removeBtn.disabled = state.running;
        removeBtn.title = state.running ? "Während eines laufenden Spiels gesperrt." : "";
        removeBtn.addEventListener("click", () => {
          if (state.running) return;
          removePlayer(p.id);
          renderAll(); saveLocalState();
        });

        wrap.append(resetBtn, removeBtn);
        actionsTd.appendChild(wrap);

        tr.append(nameTd, setsTd, legsTd, statusTd, avgTd, actionsTd);
        playerBody.appendChild(tr);
      });
    }

    function renderThrowLog(){
      throwLog.innerHTML = "";

      if (!state.throws.length){
        const empty = document.createElement("div");
        empty.className = "muted";
        empty.textContent = "Noch keine Würfe erfasst.";
        throwLog.appendChild(empty);
        return;
      }

      const reversed = [...state.throws].reverse();
      reversed.forEach((t, revIdx) => {
        const originalIndex = state.throws.length - 1 - revIdx;
        const p = state.players.find(x => x.id === t.playerId);
        const who = p ? p.name : "Unbekannt";

        const row = document.createElement("div");
        row.className = "throw-entry";

        const left = document.createElement("div");
        const label = (t.num === 0)
          ? "Miss 0"
          : `${labelForMultiplier(t.mult)} ${t.num === 25 ? "Bull" : t.num}`;
        const flags = [
          t.bust ? "BUST" : null,
          t.finishAttempt ? "Finish?" : null,
          t.hitFlag ? "Treffer" : null
        ].filter(Boolean).map(x => `<span class="chip">${x}</span>`).join(" ");

        left.innerHTML = `
          <div><strong>${label}</strong> = ${t.score} P ${flags ? " " + flags : ""}</div>
          <div class="muted">von ${who} · Turn ${t.turn} · Dart ${t.dartInTurn}</div>
        `;

        const right = document.createElement("div");
        right.className = "right";

        const editBtn = document.createElement("button");
        editBtn.type = "button";
        editBtn.className = "ghost-btn";
        editBtn.textContent = "Ändern";
        editBtn.addEventListener("click", () => editThrow(originalIndex));

        const delBtn = document.createElement("button");
        delBtn.type = "button";
        delBtn.className = "ghost-btn danger";
        delBtn.textContent = "Entfernen";
        delBtn.addEventListener("click", () => {
          state.throws.splice(originalIndex, 1);
          recomputeFromThrows();
          renderAll(); saveLocalState();
        });

        right.append(editBtn, delBtn);
        row.append(left, right);
        throwLog.appendChild(row);

        if (revIdx < reversed.length - 1){
          const hr = document.createElement("hr");
          hr.className = "throw-sep";
          throwLog.appendChild(hr);
        }
      });
    }

    function renderStats(){
      const m = getMode();

      if (!state.players.length){
        statsHead.innerHTML = "";
        statsBody.innerHTML = `<tr class="empty"><td style="text-align:center; color:var(--muted);">Noch keine Daten.</td></tr>`;
        return;
      }

      if (m.type === "x01"){
        statsNote.textContent = "Darts, Singles/Doubles/Triples, Punkte, Ø Punkte/Dart.";
        statsHead.innerHTML = `
          <tr>
            <th>Name</th><th>Darts</th><th>Singles</th><th>Doubles</th><th>Triples</th><th>Punkte</th><th>Ø</th>
          </tr>
        `;
      } else if (m.type === "atc"){
        statsNote.textContent = "Darts, Treffer aufs Ziel, Fortschritt (0–21).";
        statsHead.innerHTML = `
          <tr>
            <th>Name</th><th>Darts</th><th>Treffer</th><th>Fortschritt</th><th>Aktuelles Ziel</th>
          </tr>
        `;
      } else {
        statsNote.textContent = "Darts, Singles/Doubles/Triples (auf Rundenzahlen), Punkte, Ø Punkte/Dart.";
        statsHead.innerHTML = `
          <tr>
            <th>Name</th><th>Darts</th><th>Singles</th><th>Doubles</th><th>Triples</th><th>Punkte</th><th>Ø</th>
          </tr>
        `;
      }

      // Build stats rows
      statsBody.innerHTML = "";

      state.players.forEach(p => {
        ensureStats(p.id);
        const s = state.statsTotals[p.id];
        const tr = document.createElement("tr");

        if (m.type === "x01"){
          const avg = s.darts ? (s.points / s.darts).toFixed(1) : "0.0";
          tr.innerHTML = `
            <td>${p.name}</td>
            <td>${s.darts}</td>
            <td>${s.singles}</td>
            <td>${s.doubles}</td>
            <td>${s.triples}</td>
            <td>${s.points}</td>
            <td>${avg}</td>
          `;
        } else if (m.type === "atc"){
          const hits = state.throws.filter(t => t.playerId === p.id && t.hitFlag).length;
          const prog = state.atcTargetIndex[p.id] ?? 0;
          const target = getATCTargetForPlayer(p.id);
          tr.innerHTML = `
            <td>${p.name}</td>
            <td>${s.darts}</td>
            <td>${hits}</td>
            <td>${prog}/21</td>
            <td>${target === 25 ? "Bull" : target}</td>
          `;
        } else {
          const pts = state.shanghaiPoints[p.id] ?? 0;
          const avg = s.darts ? (pts / s.darts).toFixed(1) : "0.0";
          tr.innerHTML = `
            <td>${p.name}</td>
            <td>${s.darts}</td>
            <td>${s.singles}</td>
            <td>${s.doubles}</td>
            <td>${s.triples}</td>
            <td>${pts}</td>
            <td>${avg}</td>
          `;
        }

        statsBody.appendChild(tr);
      });
    }

    function renderAll(){
      renderModeInfo();
      renderPlayers();
      renderTurnInfo();
      renderCheckoutBox();
      renderThrowLog();
      renderStats();
      renderMultiplierUI();
    }

    // ============================================================
    // UI EVENTS
    // ============================================================
    gameModeSelect.addEventListener("change", () => {
      if (state.running){
        gameModeSelect.value = state.mode;
        return;
      }
      state.mode = gameModeSelect.value;
      renderAll();
      saveLocalState();
    });

    missBtn.addEventListener("click", () => addThrow(0));

    clearThrowsBtn.addEventListener("click", () => {
      if (!state.running) return;
      // Runde/Leg leeren, Spieler bleiben
      startLegFresh();
    });

    startGameBtn.addEventListener("click", () => {
      state.mode = gameModeSelect.value;
      startGame();
    });

    nextRoundBtn.addEventListener("click", () => {
      if (!state.players.length) return;
      if (!state.running) {
        // Wenn nicht running: starten wir ganz normal
        startGame();
        return;
      }
      nextRound();
    });

    resetAllBtn.addEventListener("click", () => {
      if (!confirm("Wirklich alles zurücksetzen? (Spieler bleiben, Runde & Log werden gelöscht)")) return;
      hardResetButKeepPlayers(true);
    });

    clearLocalBtn.addEventListener("click", () => {
      if (!confirm("Lokale Statistik löschen? (Offline-Modus)")) return;
      clearLocalState();
    });

    // Spieler hinzufügen: auch während laufendem oder pausiertem Leg (Offline)
    playerForm.addEventListener("submit", (e) => {
      e.preventDefault();

      if (state.players.length >= MAX_PLAYERS){
        alert("Maximal 10 Spieler.");
        return;
      }

      // Modus nur ändern, wenn Match noch nicht gestartet ist
      if (!state.matchStarted) state.mode = gameModeSelect.value;

      // Backend: nach Match-Start nicht erlauben
      if (useBackend && state.matchStarted){
        alert("Im Backend-Modus können Spieler nach Match-Start nicht hinzugefügt werden.");
        return;
      }

      const name = (playerNameInput.value.trim() || `Spieler ${state.players.length + 1}`);
      const m = getMode();

      // Startscore-Regel
      const start = (m.type === "x01")
        ? (state.matchStarted ? m.start : clampScore(startScoreInput.value, m.start))
        : 0;

      const newPlayer = {
        id: createId(),
        name,
        score: start,
        legs: 0,
        sets: 0
      };

      state.players.push(newPlayer);
      ensureStats(newPlayer.id);

      // mode-specific init
      if (m.type === "atc") state.atcTargetIndex[newPlayer.id] = 0;
      if (m.type === "shanghai") state.shanghaiPoints[newPlayer.id] = 0;

      playerNameInput.value = "";

      // currentPlayerIndex NICHT verändern
      renderAll();
      saveLocalState();
    });

    // ============================================================
    // INIT
    // ============================================================
    function init(){
      state.mode = gameModeSelect.value;
      renderThrowNumbers();
      renderAll();
      renderMultiplierUI();

      if (!useBackend){
        loadLocalState();
      } else {
        // wenn du Backend später willst: hier socket sync rein
        console.warn("useBackend=true ist aktuell nicht fertig verdrahtet. Stelle useBackend=false.");
      }
    }

    init();
  </script>
</body>
</html>